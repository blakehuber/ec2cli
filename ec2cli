#!/bin/bash
#_________________________________________________________________________
#                                                                         |
#                                                                         |
#  Author:   Blake Huber                                                  |
#  Purpose:  Display details AWS ec2 resources from cli environment       |
#  Name:     ec2cli                                                       |
#  Location: $EC2_REPO                                                    |
#  Requires: awscli, jq, dig, awk, sed                                    |
#  Environment Variables (required, global):                              |
#                                                                         |
#      SSH_KEYS            :   Dir containing ssh keys (.pem) files       |
#      AWS_ACCESS_KEY      :   IAM User Private Key                       |
#      AWS_SECRET_KEY      :   IAM User Public Key                        |
#      AWS_DEFAULT_REGION  :   Home AWS region                            |
#      EC2_REPO            :   Location of ec2cli utility                 |
#      REMOTE_RDP_PASSWD   :   Windows Login passwd (optional)            |
#                                                                         |
#  User:     $user                                                        |
#  Output:   CLI                                                          |
#  Error:    stderr                                                       |
#  Log:  $pkg_path/logs/                                                  |
#                                                                         |
#_________________________________________________________________________|

#
# global variables
#
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
pwd=$(pwd)
ec2cli_log="/var/log/$pkg.log"
lib_path="/usr/local/lib/$pkg"
host=$(hostname)
system=$(uname)
clear=$(which clear)

# source lib deps
source $lib_path/version.py        # package VERSION global var
source $lib_path/colors.sh
source $lib_path/std_functions.sh
source $lib_path/exitcodes.sh

VERSION=$__version__

# error codes
E_DEPENDENCY=1                # exit code if missing required ec2cli dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTH=4                      # exit code if authentication fails to aws
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter
E_NETWORK_ACCESS=9            # exit code if no network access from current location
E_MISC=11                     # exit code if miscellaneous (unspecified) error

# Configuration files, ancillary vars
CONFIG_DIR="ec2cli"
CONFIG_ROOT="$HOME/.config"
CONFIG_PATH="$CONFIG_ROOT/$CONFIG_DIR"
CONFIG_PATH_ALT="$HOME/.ec2cli"
REGION_CONFIGFILE="regions.list"
REFRESH_REGIONCODES="14"      # days
FLOAT_DECIMAL="1"             # number of floating point decimal places to output

#
# Formatting
#

# Initialize ansi colors
title=$(echo -e ${bold}${white})
account=$(echo -e ${orange})   # use for ansi escape color codes
options=$(echo -e ${white})
resources=${yellow}
commands=$(echo -e ${brightcyan})   # use for ansi escape color codes
regions=$(echo -e ${brightblue})
url=$(echo -e ${underline}${brightblue})
frame=$greenbold_frame
bodytext=$(echo -e ${reset}${wgray})            # report body text; set to reset for native xterm
#bodytext=$(echo -e ${reset})            # report body text; set to reset for native xterm
ast="$(echo -e ${brightyellow})"    # astrick
backcolor=$(echo -e ${brightgreen})

#
# system functions  ------------------------------------------------------
#


function ec2cli_help(){
  cat <<EOM

                  ${title}ec2cli${bodytext} help contents

    ${white}${BOLD}SYNOPSIS${UNBOLD}${bodytext}:

        $ ec2cli  [${options}OPTION${bodytext}]  ${resources}RESOURCE${bodytext}  [${cyan}COMMAND${bodytext}]  [${regions}REGIONCODE${bodytext}]

                       -i | --instances
                       -b | --subnets
                       -g | --secgroups
                       -s | --snapshots
                       -t | --tags
                       -v | --volumes
                       -n | --vpcs
                      [-A | --all     ]
                      [-d | --debug   ]
                      [-h | --help    ]
                      [-p | --profile  <value> ]
                      [-r | --region  ]
                      [-s | --sort  {size | id | date} ]
                      [-V | --version ]
    ${white}${BOLD}OPTIONS${UNBOLD}${bodytext}:
          ${options}-A${bodytext},${options} --all${bodytext}          Analyze resources in all AWS Regions
          ${options}-d${bodytext},${options} --debug${bodytext}        Enable verbose logging & messaging
          ${options}-h${bodytext},${options} --help${bodytext}         Display this help menu
          ${options}-p${bodytext},${options} --profile${bodytext}      Profilename of an IAM user or role
          ${options}-r${bodytext},${options} --region${bodytext}       AWS region code (ex: us-east-1)
          ${options}-S${bodytext},${options} --sort${bodytext}         Sort by size, id, date
          ${options}-V${bodytext},${options} --version${bodytext}      Print version info

    ${white}${BOLD}RESOURCES${UNBOLD}${bodytext}:
          ${resources}-a${bodytext},${resources} --images       ${bodytext}Amazon Machine Images (AMI)
          ${resources}-b${bodytext},${resources} --subnets      ${bodytext}Virtual Private Cloud (VPC) Subnets
          ${resources}-g${bodytext},${resources} --secgroups    ${bodytext}Security Group Details
          ${resources}-i${bodytext},${resources} --instances    ${bodytext}EC2 Instance Details
          ${resources}-n${bodytext},${resources} --vpc          ${bodytext}Virtual Private Cloud (VPC) Networks
          ${resources}-N${bodytext},${resources} --network      ${bodytext}VPC, Subnet, & Security Groups
          ${resources}-s${bodytext},${resources} --snapshots    ${bodytext}EBS Snapshot Details
          ${resources}-P${bodytext},${resources} --spot         ${bodytext}Spot Market Pricing (all regions)
          ${resources}-t${bodytext},${resources} --tags         ${bodytext}Tags Details for EC2 Services
          ${resources}-v${bodytext},${resources} --volumes      ${bodytext}Elastic Block Store (EBS) Volumes

    ${white}${BOLD}COMMANDS${UNBOLD}${bodytext}:
          ${cyan}list               ${bodytext}List aws resource details [DEFAULT]
          ${cyan}attach             ${bodytext}Attach/ Detach aws resource
          ${cyan}create             ${bodytext}Create new aws resource
          ${cyan}run                ${bodytext}Run/ start existing aws resource

    ${white}${BOLD}REGIONCODES${UNBOLD}${bodytext}:
          ${regions}ap-east-1          ${bodytext}Asia Pacific (Hong Kong)
          ${regions}ap-northeast-1     ${bodytext}Asia Pacific (Tokyo, Japan)
          ${regions}ap-northeast-2     ${bodytext}Asia Pacific (Seoul, Korea)
          ${regions}ap-northeast-3     ${bodytext}Asia Pacific (Osaka, Japan)
          ${regions}ap-south-1         ${bodytext}Asia Pacific (Mumbai, India)
          ${regions}af-south-1         ${bodytext}Africa (Cape Town, South Africa)
          ${regions}ap-southeast-1     ${bodytext}Asia Pacific (Singapore)
          ${regions}ap-southeast-2     ${bodytext}Asia Pacific (Sydney, Austrailia)
          ${regions}ca-central-1       ${bodytext}Canada (Montreal, CA)
          ${regions}eu-central-1       ${bodytext}Europe (Frankfurt, Germany)
          ${regions}eu-west-1          ${bodytext}Europe (Ireland)
          ${regions}eu-west-2          ${bodytext}Europe (London, UK)
          ${regions}eu-west-3          ${bodytext}Europe (Paris, France)
          ${regions}eu-north-1         ${bodytext}Europe (Stockholm, Sweden)
          ${regions}eu-south-1         ${bodytext}Europe (Milan, Italy)
          ${regions}me-south-1         ${bodytext}Bahrain (Middle East)
          ${regions}sa-east-1          ${bodytext}South America (Sao Paulo, Brazil)
          ${regions}us-east-1          ${bodytext}United States (N. Virgina)
          ${regions}us-east-2          ${bodytext}United States (Ohio)
          ${regions}us-west-1          ${bodytext}United States (N. California)
          ${regions}us-west-2          ${bodytext}United States (Oregon)

          If region code omitted, defaults to AWS default region

        For additional help, see ${url}https://github.com/fstab50/ec2cli${bodytext}


EOM
    exit 0
}

function std_logger(){
    local msg="$1"
    local prefix="$2"
    #
    if [ ! $prefix ]; then
        prefix="[INFO]"
    fi
    if [[ ! $ec2cli_log ]]; then
        echo "$prefix: $pkg ($VERSION): failure to call std_logger, $ec2cli_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg - $VERSION - $msg" >> "$ec2cli_log"
}


function std_message(){
    local msg="$1"
    local format="$3"
    #
    std_logger "$msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:5}"
        shift
    fi
    if [ $format ]; then
        echo -e "${yellow}[ $cyan$pref$yellow ]$reset  $msg" | indent04
    else
        echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent04
    fi
}


function std_error(){
    local msg="$1"
    std_logger "[ERROR]: $msg"
    echo -e "\n${yellow}[ ${red}ERROR${yellow} ]$reset  $msg\n" | indent04
}


function std_warn(){
    local msg="$1"
    std_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent04
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent04
    fi
}


function std_error_exit(){
    local msg="$1"
    local status="$2"
    std_error "$msg"
    exit $status
}


function environment_info(){
    local msg_header=$1
    local dep=$2
    local version_info
    local awscli_ver
    local boto_ver
    local python_ver
    #
    version_info=$(aws --version 2>&1)
    awscli_ver=$(echo $version_info | awk '{print $1}')
    boto_ver=$(echo $version_info | awk '{print $4}')
    python_ver=$(echo $version_info | awk '{print $2}')
    #
    if [[ $dep == "aws" ]]; then
        std_logger "[$msg_header]: awscli version detected: $awscli_ver"
        std_logger "[$msg_header]: Python runtime detected: $python_ver"
        std_logger "[$msg_header]: Kernel detected: $(echo "$version_info" | awk '{print $3}')"
        std_logger "[$msg_header]: boto library detected: $boto_ver"

    elif [[ $dep == "awscli" ]]; then
        std_message "awscli version detected: ${white}$awscli_ver${reset}" "$msg_header" "pprint" | indent04
        std_message "boto library detected: ${white}$boto_ver${reset}" "$msg_header" "pprint" | indent04
        std_message "Python runtime detected: ${white}$python_ver${reset}" "$msg_header" "pprint" | indent04
        printf -- '\n'

    elif [[ $dep == "os" ]]; then
        std_message "Kernel detected: ${white}$(echo $version_info | awk '{print $3}')${reset}" $msg_header | indent04

    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        std_message "parser detected: ${white}$(echo $version_info)${reset}" $msg_header | indent04

    else
        std_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function environment_info -->
}


function account_alias(){
    ## returns account alias (human-readable name) ##
    local profile="$1"
    alias="$(aws iam list-account-aliases --profile $profile | jq .AccountAliases[0])"
    echo "$(echo $alias | cut -c 2-30 | rev | cut -c 2-30 | rev)"
}


function authenticated(){
    ## validates authentication using iam user or role ##
    local profilename="$1"
    local response
    #
    response=$(aws sts get-caller-identity --profile $profilename 2>&1)
    if [ "$(echo $response | grep Invalid)" ]; then
        std_message "The IAM profile provided ($profilename) failed to authenticate to AWS. Exit (Code $E_AUTH)" "AUTH"
        return 1
    elif [ "$(echo $response | grep found)" ]; then
        std_message "The IAM user or role ($profilename) cannot be found in your local awscli config. Exit (Code $E_BADARG)" "AUTH"
        return 1
    elif [ "$(echo $response | grep Expired)" ]; then
        std_message "The sts temporary credentials for the role provided ($profilename) have expired. Exit (Code $E_AUTH)" "INFO"
        return 1
    else
        return 0
    fi
}


function set_tmpdir(){
    ## set fs pointer to writeable temp location ##
    local df=$(which df)
    #
    if [ "$($df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR
    else
        std_logger "[INFO]: Failed to find tempfs ram disk.  Using /tmp as alternate"
        TMPDIR="/tmp"
        cd $TMPDIR
    fi
}


function ec2cli_precheck(){
    local df=$(which df)
    #
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        std_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi

    # if possible, set temp fs location in memory for working calcs
    set_tmpdir

    ## check for required cli tools ##
    for prog in aws ssh dig awk sed bc; do
        if ! type "$prog" > /dev/null 2>&1; then
            std_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $DBUGMODE ]; then
            environment_info "DBUG" $prog
        fi
    done

    ## check if awscli tools are configured ##
    metadata=$(cat $lib_path/config.json | jq -r .configuration.LOCATION)
    if [ "$metadata" = "AWS" ] || [ "$metadata" = "aws" ]; then
        std_logger "Host detected at Amazon Web Services. Exempt check for awscli configuration" "INFO" $ec2cli_log
    else
        if [[ ! -f $HOME/.aws/config ]]; then
            std_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            std_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## check global environment variables, linux instances ##
	if [[ ! $(env | grep SSH_KEYS) ]]; then
		#
		# path to ec2 .pem files not found, auto-login \
		# to instances will fail when attempted
		#
		std_error "SSH_KEYS environment variable not set. Login will fail when Command 'run' attempted." $E_DEPENDENCY
	fi

    ## config directories, files ##
    if [ -d $CONFIG_ROOT ]; then
        if [ ! -d $CONFIG_PATH ]; then
            std_logger "[INFO]: Directory CONFIG_PATH ($CONFIG_PATH) not found, creating."
            mkdir $CONFIG_PATH
        fi
    else
        std_logger "[INFO]: Directory CONFIG_ROOT ($CONFIG_ROOT) not found, use alternate."
        if [ ! -d $CONFIG_PATH_ALT ]; then
            std_logger "[INFO]: Directory CONFIG_PATH_ALT ($CONFIG_PATH_ALT) not found, creating."
            mkdir $CONFIG_PATH_ALT
        fi
        CONFIG_PATH=$CONFIG_PATH_ALT
    fi
    #
    # <-- end function ec2cli_precheck -->
    #
}


function ec2cli_precheck-windows(){
	#
	# Windows RDP login deps (Linux client rdesktop)
	#
	# check global environment variables, windows instances
	if [[ ! $(env | grep REMOTE_RDP_PASSWD) ]]; then
		#
		# RDP password not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		std_warn "REMOTE_RDP_PASSWD global environment variable not set. Login to RDP EC2 instances will fail"
	fi

    # check RDP for accessing windows instances from Linux
	if ! type rdesktop > /dev/null 2>1; then
		#
		# RDP app not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		std_warn "${BOLD}rdesktop${UNBOLD} app not found. Login to RDP EC2 instances will fail"
	fi
    #
    # <-- end function ec2cli_precheck-windows -->
    #
}


function adjust_units(){
    ## adjusts size and units of disk based on inc of 1024 ##
    local sum="$1"      # raw sum
    local adj_sum
    local unit
    #1048576
    if [ $sum -gt $((1024*1024)) ]; then
        adj_sum=$(echo "scale=$FLOAT_DECIMAL; $sum/1024/1024" | bc)
        unit="PB"
    elif [ $sum -gt 1024 ]; then
        adj_sum=$(echo "scale=$FLOAT_DECIMAL; $sum/1024" | bc)
        unit="TB"
    else
        adj_sum=$sum
        unit="GB"
    fi
    echo "$adj_sum $unit"
}


function ec2cli_attach_volume(){
    # vars
    local CHOICE              # user selection
    local DEFAULTDEV          # default device
    local DEVICE
    local tmpVOLID
    local tmpINSTANCEID
    local INSTANCEID
    local REGION=$1
    local MAXCT               # array length
    local msg                 # msg string
    local VALID               # loop break
    local VOLID
    local sp="${frame}|${bodytext}"       # separator

    ## choose volume ##---------------------------------------------------
    echo -e "\n${BOLD}Volume choices: ${UNBOLD}${blue_frame}$REGION${reset}" | indent18
    ec2cli_list_volumes $REGION > $TMPDIR/.text-output0.tmp
    grep "vol-" $TMPDIR/.text-output0.tmp > $TMPDIR/.text-output1.tmp

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a VOLUMES < $TMPDIR/.text-output1.tmp

    # array max length
    MAXCT=${#VOLUMES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0
    while (( i < $MAXCT )); do
            echo "($i): ""${VOLUMES[$i]}" >> $TMPDIR/.arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header display choices from array
    echo -e "${greenbold_frame}     ____________________________________________________________________${reset}"
    echo -e "\n     $sp VolumeID              $sp GB $sp CreateDate  $sp  State  $sp  InstanceId $sp"
    echo -e "${greenbold_frame}     ____________________________________________________________________${reset}\n"
    #print_header "$sp VolumeID $sp GB $sp CreateDate $sp State $sp InstanceId $sp"

    # values
    awk  '{ printf "%-4s %-20s %-3s %-3s %-2s %-11s %-9s %-16s %-2s %-2s %-11s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12}' $TMPDIR/.arrayoutput.tmp
    echo -e "${greenbold_frame}     ____________________________________________________________________${reset}\n"

    # Enter control structure to get user selection and validate
    VALID=0 # set loop break

    while [ $VALID -eq 0 ]; do
        # read volume choice in from user
        echo ""
        read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
        echo ""
            if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
            # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done
    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpVOLID=${VOLUMES[$CHOICE]}
    VOLID=$(echo $tmpVOLID | cut -c 1-12)
    echo "Volume "$VOLID" chosen."

    # clean up
    rm $TMPDIR/.text-output0.tmp $TMPDIR/.text-output1.tmp $TMPDIR/.arrayoutput.tmp

    ## choose instance ## ------------------------------------------------
    echo -e "\n${BOLD}EC2 Instance choices: ${UNBOLD}$REGION\n" | indent18
    ec2cli_list_instances $REGION > $TMPDIR/.text-output0.tmp
    grep "i-" $TMPDIR/.text-output0.tmp > $TMPDIR/.text-output1.tmp

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a INSTANCES < $TMPDIR/.text-output1.tmp

    # array max length
    MAXCT=${#INSTANCES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0
    while (( i < $MAXCT )); do
            echo "($i): ""${INSTANCES[$i]}" >> $TMPDIR/.arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header to display choices from array
    echo -e "\n     InstanceId    Type     State    SecurityGroup    Root-Volume     Version"
    echo -e "     ----------- ---------  -------  --------------   ------------   ---------"

    # values
    awk  '{ printf "%-4s %-11s %-10s %-8s %-16s %-14s %-9s \n", \
        $1, $2, $3, $4, $5, $6, $7}' $TMPDIR/.arrayoutput.tmp

    # Enter control structure to get user selection and validate
    VALID=0 # loop break
    while [ $VALID -eq 0 ]; do
            # read volume choice in from user
            echo ""
            read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
            echo ""
            if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done

    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpINSTANCEID=${INSTANCES[$CHOICE]}
    INSTANCEID=$(echo $tmpINSTANCEID | cut -c 1-10)
    echo -e "Instance "$INSTANCEID" chosen.\n"

    # clean up
    rm $TMPDIR/.text-output0.tmp $TMPDIR/.text-output1.tmp $TMPDIR/.arrayoutput.tmp

    ## choose device ## --------------------------------------------------
    read -p  "${yellow}  Enter device to mount to [/dev/sda1]:  ${reset}" DEVICE
    DEFAULTDEV="/dev/sda1"

    if [ -z "$DEVICE" ]
    then
      DEVICE=$DEFAULTDEV
    else
      DEVICE=$DEVICE
    fi

    # execute
    echo -e "\nAttaching volume.....\n"
    aws ec2 --profile $PROFILE attach-volume \
        --volume-id $VOLID \
        --instance-id $INSTANCEID \
        --device $DEVICE \
        --output table
    ## FIXME: capture error conditions if attach fails
    ## send to $msg

    # log and exit
    if [[ "cat $msg | grep error" ]]; then
        # errors while attaching
        std_error_exit "$msg" $E_MISC
    else
        std_message "Volume $VOLID attached to instance $INSTANCEID in region $REGION." INFO
    fi
    #
    # <-- end function ec2cli_attach_volume -->
    #
}


function ec2cli_create_images(){
    # vars
    local REGION=$1         # aws region
    local CHOICE            # variable to hold user choice
    local DESCRIPTION       # user provided description for newly created image
    local INSTANCEID        # instance chosen for image creation
    local MAXCT             # max number of values in array
    local NOW               # date, formatted
    local NAME              # user provided name for newly created image
    local VALID             # loop break

    # pull json info, all instances in region
    aws ec2 describe-instances --region $REGION --profile $PROFILE --output json > $TMPDIR/.jsonoutput.tmp

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' $TMPDIR/.jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}          # count instances found

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_create_images: attempt to create AMI image"
        std_message "No EC2 instances found in region $REGION." INFO
        return
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' $TMPDIR/.jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' $TMPDIR/.jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' $TMPDIR/.jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' $TMPDIR/.jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' $TMPDIR/.jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' \
            $TMPDIR/.jsonoutput.tmp | cut -c 1-15) )
    # limit length of tag fields to 20 chars. NOTE: ARRAY ASSIGNMENT NOT WORKING CORRECTLY
    ARR_TAG=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' \
            $TMPDIR/.jsonoutput.tmp | cut -c 1-20) )

    # > 0 instances in region, print region identifier
    printf "\n${white}${BOLD}EC2 Instances${UNBOLD}${reset} : $REGION\n\n" | indent18

    # output table of json array
    i=0
    for id in ${ARR_ID[*]}; do
        echo "($i): "${ARR_ID[$i]} ${ARR_TYPE[$i]} ${ARR_STATE[$i]} ${ARR_SG[$i]} \
              ${ARR_DEV[$i]} ${ARR_TAG[$i]} >> $TMPDIR/.arrayoutput.tmp
        # incr ct
        i=$(( $i+1 ))
    done

    # display choices from array
    echo -e "       InstanceID           Type       State    SecurityGroup    Root-Volume            Description"
    echo -e "       -------------------  ---------  -------  ---------------  ---------------------  -------------------------"
    # values
    awk  '{ printf "%-6s %-20s %-10s %-8s %-16s %-22s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' $TMPDIR/.arrayoutput.tmp
    # footer
    printf "\nTotal Instances in region [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n" | indent10

    # get user input while checking type and range
    VALID=0    # set loop break
    while [ $VALID -eq 0 ]; do
            # read choice in from user
            echo ""
            read -p "${yellow}  Enter instance # to create Amazon Machine Image (AMI) [quit]: ${reset}" CHOICE
            echo ""

            # assign instance to choice
            if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
                    ### FIXME:  Fails if enter integer with 2 digits ###
            else
                    if [[ -z "$CHOICE" ]]; then
                            # CHOICE is blank, clean up and assign default [quit]
                            rm $TMPDIR/.arrayoutput.tmp
                            return
                            #exit $E_USER_CANCEL
                    else
                            # valid user entry, exit loop
                            VALID=1
                    fi
            fi
    done

    ## retrieve tag values Description, Name ##
    INSTANCEID=${ARR_ID[$CHOICE]}
    # retrieve json object for selected instance
    aws ec2 --profile $PROFILE describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    NOW=$(date +"%Y-%m-%dT%H:%M:%S")    # date + 24 hr time
    TIME=$(date +"%H.%M.%S")            # 24 hr time stamp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' $TMPDIR/.jsoninstance.tmp) )

    # search thru array of tags assoc with this instances
    NAME=""             # initialize
    DESCRIPTION=""      # initialize
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name, map to description
        if [ $key == "Name" ] || [ $key == "name" ]; then
            DESCRIPTION="$(jq -r ".Reservations[].Instances[].Tags[$i].Value" $TMPDIR/.jsoninstance.tmp)""($INSTANCEID)"
        fi
        # get description
        #if [ $key == "Description" ] || [ $key == "description" ]; then
        #    #DESCRIPTION=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
        #    DESCRIPTION="InstanceId_"$INSTANCEID  # STUB until issue 33 permanent fix
        #fi
        # increment
        i=$(( $i+1 ))
    done

    ## defaults if no tags ##
    if [ "$NAME" == "" ]; then
        # no name tag exists, append unique 24 hr time stamp
        NAME="AMI."$TIME
    fi
    if [ "$DESCRIPTION" == "" ]; then
        # no description tag exists
        DESCRIPTION="InstanceId_"$INSTANCEID
    fi

    # create image
    aws ec2 --profile $PROFILE create-image \
        --region $REGION \
        --instance-id $INSTANCEID \
        --name "$NAME" \
        --description "$DESCRIPTION" \
        --output table

    # user msg, locate after ec2 create-image called in case of failure
    echo -e "\n** Amazon Machine Image creation start **\n" | indent02
    echo -e "${white}AMI Name :${reset} "$NAME | indent02
    echo -e "${white}AMI Description :${reset} "$DESCRIPTION | indent02
    echo ""
    # log
    std_logger "INFO:  AMI image [$NAME] creation start"

    # clean up
    rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.arrayoutput.tmp $TMPDIR/.jsoninstance.tmp
    #
    # <-- end function ec2cli_create_images -->
    #
}


function ec2cli_create_snapshot(){
    # vars
    local i                 # counter
    local REGION=$1
    local NOW="$(date +"%Y-%m-%d.T%H:%M")"
    local PROGRESSMSG="Snapshot creation started... "
    local VALID             # loop break
    local GVALID            # global valid for creating more than 1 snapshot

    GVALID=0
    while [ $GVALID -eq 0 ]; do
        #
        ### choose volume ###
        #
        # json object of all ebs volumes in region
        aws ec2 --profile $PROFILE describe-volumes --region $REGION --output json > $TMPDIR/.jsonoutput.tmp
        ARR_ID=( $(jq -r .Volumes[].VolumeId $TMPDIR/.jsonoutput.tmp) )
        MAXCT=${#ARR_ID[*]}
        if [[ $MAXCT -eq 0 ]]; then
            # no ebs volumes to snapshot, exit
            rm $TMPDIR/.jsonoutput.tmp
            std_error_exit "No EBS volumes in region $REGION. Exiting." $E_DEPENDENCY
        fi

        # volumes exist in region, process remainder of json object
        ARR_SIZE=( $(jq -r .Volumes[].Size $TMPDIR/.jsonoutput.tmp) )
        ARR_STATE=( $(jq -r .Volumes[].State $TMPDIR/.jsonoutput.tmp) )
        ARR_INSTANCE=( $(jq -r .Volumes[].Attachments[].InstanceId $TMPDIR/.jsonoutput.tmp) )
        ARR_TYPE=( $(jq -r .Volumes[].VolumeType $TMPDIR/.jsonoutput.tmp) )
        ARR_ENCRYPT=( $(jq -r .Volumes[].Encrypted $TMPDIR/.jsonoutput.tmp) )
        ARR_AZ=( $(jq -r .Volumes[].AvailabilityZone $TMPDIR/.jsonoutput.tmp) )
        ARR_TAG=( $(jq -r .Volumes[].Tags[0].Value $TMPDIR/.jsonoutput.tmp | cut -c 1-20) )

        # display choices
        printf "\n${white}${BOLD}EBS Volumes${UNBOLD}${reset} : $REGION\n\n" | indent18
        # create table of json array
        i=0
        for id in ${ARR_ID[*]}; do
            echo "($i): "${ARR_ID[$i]} ${ARR_SIZE[$i]} ${ARR_STATE[$i]} ${ARR_INSTANCE[$i]} \
                  ${ARR_TYPE[$i]} ${ARR_AZ[$i]} ${ARR_TAG[$i]} >> $TMPDIR/.arrayoutput.tmp
            # incr ct
            i=$(( $i+1 ))
        done
        # display choices from array
        echo -e "     VolumeID               GB  State     InstanceId           VolType   Avail-Zone  Tag"
        echo -e "     ---------------------  --  --------  -------------------  --------  ----------  --------------------"
        # values
        awk  '{ printf "%-4s %-22s %-3s %-9s %-20s %-9s %-11s %-2s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' $TMPDIR/.arrayoutput.tmp
        # footer
        printf "\nTotal Volumes in region [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n" | indent10
        # clean up
        rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.arrayoutput.tmp

        # get user input while checking type and range
        VALID=0    # set loop break
        while [ $VALID -eq 0 ]; do
                # read choice in from user
                echo ""
                read -p "${yellow}  Enter choice for hit return to quit [quit]: ${reset}" CHOICE
                echo ""

                # assign instance to choice
                if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
                        # invalid user entry
                        echo "You must enter an integer number between 0 and $(( $MAXCT-1 )) or quit."
                        ### FIXME:  Fails if enter integer with 2 digits ###
                else
                        if [[ -z "$CHOICE" ]]; then
                                # CHOICE is blank, assign default [quit]
                                return
                        else
                                # valid user entry, exit loop
                                VALID=1
                        fi
                fi
        done
        # assign vol ID to be snapshotted
        VOLID=${ARR_ID[$CHOICE]}

        ### create snapshot ###
        # description = concatenate volume date + Name tag
        NAMETAG=$(aws ec2 --profile $PROFILE describe-volumes \
                --region $REGION \
                --volume-id  $VOLID \
                --query 'Volumes[*].[Tags[0].Value]' \
                --output text)
        DESCRIPTION=$NOW", ""$NAMETAG"
        # start snapshot, output msg
        aws ec2 --profile $PROFILE create-snapshot \
                --output table \
                --region $REGION \
                --volume-id $VOLID \
                --description "$DESCRIPTION"
        # log, user msg
        std_message "Creating snapshot of volume [$VOLID] in region $REGION." INFO

        # option to create more snapshots
        echo ""
        read -p "${yellow}  Create another snapshot? [quit]: ${reset}" CHOICE
        echo ""
        if [[ -z "$CHOICE" ]]; then
                # CHOICE is blank, assign default (quit)
                GVALID=1
                return
        else
            case $CHOICE in
            y | Y | yes | Yes)
                GVALID=0
                ;;
            *)
                GVALID=1
                return
                ;;
            esac
        fi
    # end global while loop
    done
    #
    # <-- end function ec2cli_create_snapshot -->
    #
}


function ec2cli_create_tag(){
    local region="$1"
    local resource_id="$2"
    local KEY
    local VALID
    local VALUE

    # resource
    if [ ! $resource_id ]; then
        echo -e "\n  Enter the resource ID to tag:"
        read -p "${yellow}  ResourceId: ${reset}" resource_id
        echo ""
    fi

    case $resource_id in
        *\ * )
            echo "Resource ID cannot contain spaces or special characters."
        ;;
    esac
    # tag components:
    VALID=0    # set loop break
    while [[ $VALID -eq 0 ]]; do
        # get user input [KEY] while checking contents
        echo -e "\n  Enter the key name of the tag to create or update:"
        read -p "${yellow}  Key: ${reset}" KEY
        echo ""
        if [[ "$KEY" =~ \ |\' ]]; then
            echo "Key cannot contain spaces or special characters."
        else
            # get user input [keyvalue]
            echo -e "\n  Enter the tag value:"
            read -p "${yellow}  Tag Value: ${reset}" VALUE
            echo ""
            VALID=1    # break
        fi
    done

    # create tag
    aws ec2 --profile "$PROFILE" --region "$region" create-tags \
        --resources "$resource_id" \
        --tags Key="$KEY",Value="$VALUE"

    # Output list of all tags
    ec2cli_list_tags  "$region" "$resource_id"
    #
    # <-- end function ec2cli_cretae-tag -->
    #
}


function ec2cli_list_instances(){
    # vars
    local TOTAL                                 # region EC2 instance count
    local REGION=$1                             # region identifier
    local sort_column="$2"                      # column to use when sorting all fields
    local NOW                                   # date, formatted
    local LAUNCHTIME                            # date/time launched from json object
    local EPOCHLT                               # LAUNCHTIME in epoch seconds
    local RUNSECS                               # runtime in sec
    local MAXCT                                 # max length of array (json object)
    local total_width="141"                     # max width of cli output
    local total_width=$(( $(tput cols) - 4 ))

    if [ "$export" = "true" ]; then
        echo -e "\nExport Data to Comma Separated Value Format -- ${title}Instances${bodytext}\n" | indent04
        read -p "    Export File Location? [ $pwd ]: " choice | indent04
        if [ -z "$choice" ]; then
            path="$pwd"
        elif [ "$choice" = "q" ]; then
            return 0
        else
            path="$choice"
        fi
        std_message "Exporting data to comma separated value (csv) file." "INFO" | indent04
        python3 "$lib_path/csv_generator.py" --profile "$PROFILE" --type instances --region "$REGION" --filepath "$path"
        return 0
    fi

    # pull json info, all instances in region
    if [ "$ALL_REGIONS" ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat ${CONFIG_PATH}/${REGION_CONFIGFILE} | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile "$PROFILE" describe-instances \
                --region "$region" --output json >> $TMPDIR/.jsonoutput.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile "$PROFILE" describe-instances --region "$REGION" --output json > $TMPDIR/.jsonoutput.tmp
    fi

    # retrieve account name
    ACCT_ALIAS=$(account_alias "$PROFILE")

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' $TMPDIR/.jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}    # count instances found

    if [ "$MAXCT" = "null" ] || [ "$MAXCT" -eq 0 ]; then
        # no instances in region, print footer
        std_logger "INFO: function ec2cli_list_instances: list instances"
        std_message "${title}0${bodytext} instances in region [$REGION]" "INFO"  | indent10
        return 0
    fi

    # print and format output
    sp="${frame}|${bodytext}"       # separator
    if (( $(tput cols) >= "174" )); then
        FULL_CLI="True"
        std_logger "[INFO]: FULL_CLI set to True, Full width output"
        total_width="169"
    else
        total_width="139"
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' $TMPDIR/.jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' $TMPDIR/.jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' $TMPDIR/.jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' $TMPDIR/.jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' $TMPDIR/.jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' $TMPDIR/.jsonoutput.tmp) )
    # limit length of tag fields to 20 chars
    ARR_TAGK1=( $(jq -r '.Reservations[].Instances[].Tags[0].Key' $TMPDIR/.jsonoutput.tmp | cut -c 1-17) )
    ARR_TAGV1=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' $TMPDIR/.jsonoutput.tmp | cut -c 1-17) )
    ARR_TAGK2=( $(jq -r '.Reservations[].Instances[].Tags[1].Key' $TMPDIR/.jsonoutput.tmp | cut -c 1-17) )
    ARR_TAGV2=( $(jq -r '.Reservations[].Instances[].Tags[1].Value' $TMPDIR/.jsonoutput.tmp | cut -c 1-17) )

    #
    # instances in region.  test if running instances
    #

    if [[ "$(printf '%s\n' "${ARR_STATE[@]}" | grep "running")" ]] || \
        [[ "$(printf '%s\n' "${ARR_STATE[@]}" | grep "stopping")" ]]; then
        #
        # at least 1 running instance found, calc runtime
        i=0     # counter
        r=0     # running instance count
        s=0    # stopped instance count

        while (( i < $MAXCT )); do
            if [[ "${ARR_STATE[$i]}" == "running" ]] || [[ "${ARR_STATE[$i]}" == "stopping" ]]; then
                # calc now in UTC epoch seconds
                NOW=$(date -u +%s)

                # calc launchtime
                LAUNCHTIME="${ARR_LT[$i]}"
                EPOCHLT=$(date -d"$LAUNCHTIME" +%s)
                RUNSECS=$(( $NOW-$EPOCHLT ))    # runtime (seconds)
                RT[$i]=$(convert_time $RUNSECS)
                # track # running instances
                r=$(( $r+1 ))
            else
                # if not running, blank runtime
                RT[$i]="-"
            fi
            # convert public IP format
            if [ "${ARR_IP[$i]}" == "null" ]; then
                # alter IP format
                ARR_IP[$i]="-"
            fi
            i=$(( $i+1 ))    # incr counter
        done
        # format stats
        s=${BOLD}$(( $MAXCT - $r ))${UNBOLD}
        r=${BOLD}$r${UNBOLD}

        # print title
        printf "\n\t\t\t  ${title}EC2 INSTANCES${bodytext} : ${regions}$REGION${bodytext}  $sp  ${title}ACCOUNT${bodytext} : ${account}$ACCT_ALIAS${bodytext}\n"

        if [ $FULL_CLI ]; then
            #print_header "InstanceId Type State SecurityGroup Root-Volume Public-IP RunTime* Tag" $total_width .body.tmp
            print_header "$sp InstanceId $sp Type $sp State $sp SecurityGroup $sp Root-Volume $sp PublicIP $sp $sp RunTime* $sp Tag $sp" $total_width  $TMPDIR/.body.tmp
        else
            print_header "$sp InstanceId $sp Type $sp State $sp SecurityGroup $sp Root-Volume $sp PublicIP $sp $sp RunTime* $sp" $total_width  $TMPDIR/.body.tmp
        fi

        ## output table of json array ##
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_TYPE[$i]} $sp ${ARR_STATE[$i]} $sp ${ARR_SG[$i]} $sp \
                    ${ARR_DEV[$i]} $sp ${ARR_IP[$i]} $sp $sp ${RT[$i]} $sp ${ARR_TAGK1[$i]}:${ARR_TAGV1[$i]} $sp" >> $TMPDIR/sort.tmp
                i=$(( $i+1 ))
            done
        else
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_TYPE[$i]} $sp ${ARR_STATE[$i]} $sp ${ARR_SG[$i]} $sp \
                    ${ARR_DEV[$i]} $sp ${ARR_IP[$i]} $sp $sp ${RT[$i]} $sp" >> $TMPDIR/sort.tmp
                i=$(( $i+1 ))
            done
        fi
        if [ ! $sort_column ]; then
            sort_column="runtime"
        fi
        case $sort_column in
            id | Id | ID | SnapshotId)
                column=2; cat $TMPDIR/sort.tmp | sort -k"$column" -n >> $TMPDIR/.body.tmp;;
            size | Size)
                column=4; cat $TMPDIR/sort.tmp | sort -k"$column" >> $TMPDIR/.body.tmp;;
            runtime)
                column=15; cat $TMPDIR/sort.tmp | sort -k$column -n >> $TMPDIR/.body.tmp;;
        esac
        rm $TMPDIR/sort.tmp    # clean up
        #
        # print and format output
        #
        if [ $FULL_CLI ]; then
            awk  '{ printf "%-2s %-20s %-2s %-11s %-2s %-9.9s %-2s %-21.21s %-2s %-22s %-2s %-15s %-2s %-13s %-2s %-33.33s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $14, $15, $16, $17, $18}' $TMPDIR/.body.tmp | indent02
        else
            awk  '{ printf "%-2s %-21s %-2s %-12s %-2s %-9.9s %-2s %-21.21s %-2s %-23s %-2s %-16s %-2s %-15.15s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $14, $15, $16}' $TMPDIR/.body.tmp | indent02
        fi
        # print footer
        if [ $ALL_REGIONS ]; then
            print_footer "Total Instances across $REGION_CT regions: ${title}$MAXCT${bodytext}  |  ${title}$r${bodytext} running, ${title}$s${bodytext} stopped  ($ast*${bodytext}sorted)" $total_width
        else
            print_footer "Total Instances [$REGION]: ${title}$MAXCT${bodytext}  |  ${title}$r${bodytext} running, ${title}$s${bodytext} stopped   ($ast*${bodytext}sorted)" $total_width
        fi
    else
        ### -- no running instances -- ###
        printf "\n${title}EC2 INSTANCES${bodytext} : ${regions}$REGION${bodytext}  $sp  ${title}ACCOUNT${bodytext}: ${account}$ACCT_ALIAS${bodytext}\n" | indent18
        print_header "$sp InstanceId* $sp Type $sp State $sp SecurityGroup $sp Root-Volume $sp Tag $sp" $total_width $TMPDIR/.body.tmp
        #
        # output table of json array
        #
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_TYPE[$i]} $sp ${ARR_STATE[$i]} $sp ${ARR_SG[$i]} \
                      $sp ${ARR_DEV[$i]} $sp ${ARR_TAGK1[$i]}:${ARR_TAGV1[$i]},${ARR_TAGK2[$i]}:${ARR_TAGV2[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print full format
            awk  '{ printf "%-2s %-21s %-2s %-12s %-2s %-9.9s %-2s %-21.21s %-2s %-23s %-2s %-64.64s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13}' $TMPDIR/.body.tmp | indent02
            # print footer
            print_footer "Total Instances [$REGION]: ${title}$MAXCT${bodytext}    *No running instances" $total_width
        else
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_TYPE[$i]} $sp ${ARR_STATE[$i]} $sp ${ARR_SG[$i]} \
                      $sp ${ARR_DEV[$i]} $sp ${ARR_TAGK1[$i]}:${ARR_TAGV1[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print narrow format
            awk  '{ printf "%-2s %-21s %-2s %-12s %-2s %-9.9s %-2s %-21.21s %-2s %-23s %-2s %-34.34s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13}' $TMPDIR/.body.tmp | indent02
            # print footer
            print_footer "Total Instances [$REGION]: ${title}$MAXCT${bodytext}    *No running instances (1 or more columns trucated)" $total_width
        fi
    fi

    # clean up
    rm $TMPDIR/.body.tmp $TMPDIR/.jsonoutput.tmp

    #
    # <-- end function ec2cli_list_instances -->
    #
}


function ec2cli_list_images(){
    # vars
    local i             # counter
    local REGION=$1     # region passed from global identifier
    local NUMLIST       # boolean parameter, 1 = output numbered list
    local MAXCT         # array length
    local total_width="137"
    local sp="${frame}|${bodytext}"       # separator
    declare -a REGIONS
    # print out numbered list of instances?
    if [[ $2 ]] && [[ $2 -eq 1 ]]; then NUMLIST=1; fi

    # retrieve json array
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-images \
                --region $region --output json --owner self >> $TMPDIR/.jsonimages.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-images --region $REGION --output json --owner self > $TMPDIR/.jsonimages.tmp
    fi

    # retrieve account name
    ACCT_ALIAS="$(account_alias $PROFILE)"

    ARR_IMAGEID=( $(jq -r ".Images[].ImageId" $TMPDIR/.jsonimages.tmp) )
    MAXCT=${#ARR_IMAGEID[*]}    # values in array

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_list_images: list AMI images"
        std_message "No Amazon Machine Images found in region $REGION." INFO
        rm $TMPDIR/.jsonimages.tmp    # clean up
        return
    fi

    # images exist in region, retrieve all other values
    ARR_TYPE=( $(jq -r ".Images[].ImageType" $TMPDIR/.jsonimages.tmp) )
    ARR_VTYPE=( $(jq -r ".Images[].VirtualizationType" $TMPDIR/.jsonimages.tmp) )
    ARR_CREATEDATE=( $(jq -r ".Images[].CreationDate" $TMPDIR/.jsonimages.tmp) )
    ARR_SNAP0=( $(jq -r ".Images[].BlockDeviceMappings[0].Ebs.SnapshotId" $TMPDIR/.jsonimages.tmp) )
    ARR_SNAP1=( $(jq -r ".Images[].BlockDeviceMappings[1].Ebs.SnapshotId" $TMPDIR/.jsonimages.tmp) )
    ARR_NAME=( $(jq -r ".Images[].Name" $TMPDIR/.jsonimages.tmp | cut -c 1-25) )    # limit to 25 chars
    ARR_DESCR=( $(jq -r ".Images[].Description" $TMPDIR/.jsonimages.tmp  | cut -c 1-35) )

    # convert date-time format to %Y-%m-%d.T%H:%M
    i=0     # initialize counter
    for date in ${ARR_CREATEDATE[*]}; do
        ARR_CREATEDATE[$i]=$(date -d${ARR_CREATEDATE[$i]}  +%Y-%m-%d.T%H:%M)
        # echo "Formatted create date is: "${ARR_CREATEDATE[$i]}    # TESTING
        # increment counter
        i=$(( $i+1 ))
    done

    # print header
    print_header "$sp AMI-id $sp CreateDateTime $sp Type $sp vType $sp SnapshotId $sp Tags $sp" $total_width $TMPDIR/.header.tmp

    # create table of json array
    i=0
    for image in ${ARR_IMAGEID[*]}}; do
        echo "$sp ${ARR_IMAGEID[$i]} $sp  ${ARR_CREATEDATE[$i]} $sp  ${ARR_TYPE[$i]} $sp  \
            ${ARR_VTYPE[$i]} $sp ${ARR_SNAP0[$i]}""  $sp  ${ARR_DESCR[$i]} $sp " >> $TMPDIR/.body.tmp
        i=$(( $i+1 ))
    done
    # sort and combine results
    cat $TMPDIR/.header.tmp > $TMPDIR/.output.tmp
    cat $TMPDIR/.body.tmp | sort -k +2 >> $TMPDIR/.output.tmp

    ## print and format output ##
    # header, region identifier
    printf "\n${white}${BOLD}AMAZON MACHINE IMAGES (AMI) : ${UNBOLD}${reset} $REGION  $sp  ACCOUNT: ${account}$ACCT_ALIAS${bodytext}\n" | indent18
    # format output
    awk  '{ printf " %-3s %-21s  %-3s %-17s  %-3s %-10s  %-3s %-8s  %-3s %-23s %-2s %-35s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13}' $TMPDIR/.output.tmp | indent02
    # footer
    print_footer "Total AMI Count [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}" $total_width

    # clean up
    rm $TMPDIR/.header.tmp $TMPDIR/.jsonimages.tmp $TMPDIR/.output.tmp $TMPDIR/.body.tmp
    #
    # <-- end function ec2cli_list_images -->
    #
}


function ec2cli_parse-instance-tag(){
    # vars
    local i             # counter
    local APP           # app tag key value
    local ENV           # env (environment) tag key value
    local INSTANCEID    # id of instance passed as $2
    local key           # key representing 1 tag
    local SEARCHKEY     # search instance tags to find this key
    local TAGVALUE      # value assoc with SEARCHKEY, if exists
    local REGION        # region identifier

    REGION=$1
    INSTANCEID=$2
    SEARCHKEY=$3
    ## retrieve tag values Description, Name ##
    # retrieve json object for selected instance
    aws ec2 --profile $PROFILE describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' .jsoninstance.tmp) )

    # search thru array of tags assoc with this instances
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name
        if [[ $key == "$SEARCHKEY" ]]; then
            TAGVALUE=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
            echo $TAGVALUE
            return
        fi
        # increment
        i=$(( $i+1 ))
    done

    # clean up
    rm .jsoninstance.tmp
    #
    # <-- end function ec2cli_parse-instance-tag -->
    #
}


function ec2cli_rdp-login(){
	# vars
	local CHOICE                     # user selection variable
	local i                          # loop counter
	local IPADDRESS=$2               # public IP address of RDP windows instance
	local MAXCT                      # array size
    local USER                       # user entered userid
    local PASSWD                     # user entered passwd
	local SIZE="90%"                 # RDP session win size relative to client resolution
	local RDP_USER="Administrator"   # default rdp user, Win instance login
	local TARGET=$1                  # target EC2 instance for starting/ log in
	local VALID                      # loop break

	# verify login prereqs
	ec2cli_precheck-windows

	# load array with choices
	RDP_SIZE[0]="90%"
	RDP_SIZE[1]="1366x768"
	RDP_SIZE[2]="1400x860"
	RDP_SIZE[3]="1900x1000"
    RDP_SIZE[4]="2540x1360"
	# size of array
	MAXCT=${#RDP_SIZE[*]}

	i=0    # counter
	while (( i < $MAXCT )); do
        	echo "($i): ""${RDP_SIZE[$i]}"  >> .type.tmp
        	i=$(( $i+1 ))
	done

	# print window size choices
	echo -e "\n\n${BOLD}Select an RDP Session Window Size:${UNBOLD}\n"
	awk -F "  " '{ printf "%-4s %-20s \n", $1, $2}' .type.tmp
	# get user input while checking type and range
	VALID=0    # set loop break
	while [[ $VALID -eq 0 ]]; do
        	# read instance choice in from user
	        echo ""
        	read -p "${yellow}  Enter # RDP window resolution or hit return for relative size [90%]: ${reset}" CHOICE
	        echo ""

        	if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
				# invalid user entry
                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
        	else
				# valid user entry, exit loop
                VALID=1
        	fi
	done
	if [ -z "$CHOICE" ]
	then
        	# CHOICE is blank, default chosen
	        CHOICE=0
	fi
    # assign size
	SIZE=${RDP_SIZE[$CHOICE]}

	# log
	std_message "Starting RDP Session with $SIZE RDP window size on instance ($TARGET)." INFO

    # password
    if [[ ! $(env | grep -i REMOTE_RDP_PASSWD) ]]; then
            echo ""
            read -p "${yellow}  Enter the RDP user required for login to this windows instance: ${reset}" RDP_USER
            echo ""
            read -p "${yellow}  Enter the $RDP_USER password to establish an RDP login to this windows instance: ${reset}" REMOTE_RDP_PASSWD
            echo ""
    fi

	# Start rdp desktop session
	rdesktop -u $RDP_USER -p "$REMOTE_RDP_PASSWD" -g $SIZE -a "24" $IPADDRESS &

	### FIXME: Support multiple passwds. Solicit passwd from user or default to \
	### shell global env var (REMOTE_RDP_PASSWD) ###

    # clean up
    rm .type.tmp
    # log and exit
    std_logger "INFO: RDP Instance ($TARGET) started. RDP session size: $SIZE."
    exit 0
    #
    # <-- end function ec2cli_rdp-login -->
    #
}


function ec2cli_run_instances(){
    ##
    ##  Use to login to ec2 instances stopped or running
    ##    - will attempt to locate .pem key file in SSH_KEYS dir
    ##    - if found will ssh into instance using "ec2-user"
    ##    - ec2-user (AmazonLinux, Redhat) fails,
    ##      will try ubuntu and centos usernames
    ##
	# vars
	local ACCESS                # flag if ssh access from login location
    local IPADDRESS       		# public IP of instance
	local KEY             		# name of ssh key (.pem file)
	local MAXCT           		# array length
	local MYCIDR           		# local IP of client running $pkg
	local NOW=$(date)     		# current time
	local OS              		# operating system of instance
	local PROGRESSTXT="EC2 Instance Starting Up.  Please wait... "
	local REGION=$1       		# target region
	local SSH_USER="ec2-user"   # default ssh user for login, Linux instance
	local TARGET                # instance to be started/ login
	local tmpID           		# temp holder for instance ID
	local VALID           		# loop break
    local i

    # alternative ec2 default usernames
    declare -a usernames
    usernames=(
            "ec2-user"
            "ubuntu"
            "centos"
            "admin"
        )
    #
	# choose instance -----------------
	#
	aws ec2 --profile $PROFILE describe-instances \
	        --region $REGION \
	        --output text \
	        --query "Reservations[*].Instances[*]. \
	            [InstanceId, \
	            InstanceType, \
	            State.Name, \
	            SecurityGroups[0].GroupName, \
	            BlockDeviceMappings[0].Ebs.VolumeId, \
	            PublicIpAddress, \
	            Tags[0].Value]" \
	>> $TMPDIR/.text-output1.tmp

	# Use built-in IFS to read in all lines in tmp file
	IFS=$'\n' read -d '' -r -a INSTANCES < $TMPDIR/.text-output1.tmp

	# calc array max length | test for 0 instances
	MAXCT=${#INSTANCES[*]} # IFS starts array index at 0
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_run_instances: attempt to run instances"
        std_message "No EC2 instances found in region $REGION" INFO
        return 0
    fi

    # header
    echo -e "\n${white}${BOLD}Available Instances${UNBOLD}${reset}: $REGION\n" | indent18
	# load output choice array
	i=0
	while (( i < $MAXCT )); do
	        echo "($i): ""${INSTANCES[$i]}" >> $TMPDIR/.arrayoutput.tmp
	        i=$(( $i+1 ))
	done

	# display choices from array
	echo -e "     InstanceID           Type        State    SecurityGroup         Root-Volume            PublicIP        Description"
	echo -e "     -------------------  ----------  -------  --------------------  ---------------------  --------------  -------------------------"

	# values
	awk  '{ printf "%-4s %-20s %-11s %-8s %-21s %-22s %-15s %-2s %-2s %-2s %-2s \n", \
	        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11}' $TMPDIR/.arrayoutput.tmp

	# get user input while checking type and range
	VALID=0    # set loop break

	while [ $VALID -eq 0 ]; do
	        # read choice in from user
	        echo ""
	        read -p "${yellow}  Enter instance # to start/ log in [quit]: ${reset}" CHOICE
	        echo ""

            echo "You selected: $CHOICE"

	        # assign instance to choice
	        if [[ $CHOICE -lt 0 ]] && [[ $CHOICE -ge $(( $MAXCT )) ]]; then
	                # invalid user entry
	                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
	                ### FIXME:  Fails if enter integer with 2 digits ###
	        else
	                if [[ -z "$CHOICE" ]]; then
	                        # CHOICE is blank, clean up and assign default [quit]
                            rm $TMPDIR/.arrayoutput.tmp $TMPDIR/.text-output1.tmp
	                        exit $E_USER_CANCEL
	                else
	                        # valid user entry, exit loop
	                        VALID=1
	                fi
	        fi
	done
    # msg instance to start/ login | CONVERT TO JSON
	tmpID=${INSTANCES[$CHOICE]}
	TARGET=$(echo $tmpID | awk '{print $1}')
    # msg out
	std_message "Instance ($TARGET) selected." INFO
	#
	# network access check ------------
	#
	std_message "Verifying Network Access to ($TARGET). Please wait ..." INFO

	# retrieve secuirty group(s) of selected ec2 instance
	aws ec2 --profile $PROFILE describe-instances \
	        --region $REGION \
	        --output text \
	        --instance-id $TARGET \
	        --query 'Reservations[].Instances[].SecurityGroups[*].GroupId' > .secgrp-ids.tmp

	# discover local ip
    PUBLIC_IP=$(curl -s https://ipinfo.io/ip)
    MYCIDR="$PUBLIC_IP/32"

    # grab security group details
    aws ec2 --profile $PROFILE describe-security-groups \
        --output json \
        --region $REGION \
        --group-ids $(cat .secgrp-ids.tmp) > $TMPDIR/.jsonoutput.tmp
    ARR_PORT=( $(jq -r '.SecurityGroups[].IpPermissions[].ToPort' $TMPDIR/.jsonoutput.tmp) )
    ARR_IP=( $(jq -r '.SecurityGroups[].IpPermissions[].IpRanges[].CidrIp' $TMPDIR/.jsonoutput.tmp) )
    MAXCT=${#ARR_PORT[*]}

    i=0    # counter
    for port in ${ARR_PORT[@]}; do
        if [ "$port" = "22" ] || [ "$port" = "3389" ]; then
            for ip in ${ARR_IP[@]}; do
                if [ "$ip" = "$MYCIDR" ] || [ "$ip" = "0.0.0.0/0" ]; then
                    ACCESS=1
                    i=$MAXCT    # access found, break
                fi
            done
        fi
        # incr counter
        i=$(( $i + 1 ))
    done

	if [[ $ACCESS = 1 ]]; then
	        # Access validated
			std_message "Access verified to instance ($TARGET). Proceeding..." INFO
	        # clean up
	        rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.secgrp-ids.tmp
	else
	        # No access from current login client location, clean up
	        rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.secgrp-ids.tmp
	        # log, exit
	        std_error_exit "No ssh or RDP access to instance ($TARGET). Please update security group settings. Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	#
	# start instance ------------------
	#
	# check to see if already started
    if [[ $(grep $TARGET $TMPDIR/.text-output1.tmp | grep running) ]]; then
        # instance already running, skip start
        std_message "Instance ($TARGET) already running.  Logging in..." INFO
    else
        # instance not running, attempt to start
	    aws ec2  --profile $PROFILE start-instances --region $REGION --output json --instance-ids $TARGET | jq .

	    # wait for instance to start, return after
	    aws ec2  --profile $PROFILE wait instance-running --region $REGION --instance-ids $TARGET &

	    # call function to show on screen while wait
	    delay_spinner

	    # FIXME (HACK) | login delay: loop for i seconds, display counter
    	i=10    # count in seconds
	    echo -e "\n "

	    while (( i > 0 )); do
	        printf "\rInstance available in: ""$i"" seconds"
	        sleep 1
	        i=$(( i-1 ))
	    done
    fi
    # clean up
    rm $TMPDIR/.arrayoutput.tmp $TMPDIR/.text-output1.tmp

	#
	# Log in --------------------------
	#
    std_message "Authenticating to instance ($TARGET)..." INFO
	# retrieve json object for selected instance
	aws ec2  --profile $PROFILE describe-instances \
        --region $REGION \
        --output json \
		--instance-id $TARGET > $TMPDIR/.jsonoutput.tmp

	# discover public ip assignment
	IPADDRESS=$(jq -r '.Reservations[].Instances[].PublicIpAddress' $TMPDIR/.jsonoutput.tmp)
	#
	# validate IP as public
	if [[ $IPADDRESS == "null" ]]; then
		std_error_exit "No public IP address found for ($TARGET). Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	# Check Windows or Linux
	OS=$(jq -r '.Reservations[].Instances[].Platform' $TMPDIR/.jsonoutput.tmp)

	if [[ $OS == "windows" ]]; then
			# windows instance, validate deps & log in via RDP
            # clean up
            rm $TMPDIR/.jsonoutput.tmp
			# windows login
            ec2cli_rdp-login $TARGET $IPADDRESS
	else
		# Linux instance, discover required access key
		KEY=$(jq -r '.Reservations[].Instances[].KeyName' $TMPDIR/.jsonoutput.tmp)".pem"

		# update log and login
		std_logger "INFO: Linux Instance ($TARGET) started. "
        break=0
        for user in ${usernames[@]}; do
            if [ "$break" -eq "0" ]; then
                ssh -i $SSH_KEYS/$KEY $user@$IPADDRESS 2>/dev/null
                if [ "$?" -eq 0 ]; then
                    break=1
                fi
            fi
        done

		# clean up and exit
		rm $TMPDIR/.jsonoutput.tmp
    	exit 0
	fi
    #
    # <-- end function ec2cli_run_instances -->
    #
}

function ec2cli_list_securitygroups(){
    # vars
    local REGION=$1
    local TOTAL
    local total_width="130"
    local total_width=$(( $(tput cols) - 4 ))

    # pull json info, all instances in region
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE" | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-security-groups \
                --region $region --output json >> $TMPDIR/.jsonoutput.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-security-groups \
                    --output json --region $REGION > $TMPDIR/.jsonoutput.tmp
    fi

    # number of groups
    SUM=$(jq -r '.SecurityGroups[].GroupName' $TMPDIR/.jsonoutput.tmp | wc -l)

    if [ "$SUM" = "null" ] || [ "$SUM" -eq 0 ]
    then
        # print footer if no snapshots found
        std_message "${title}0${bodytext} security groups in region [$REGION], total ${title}0${bodytext} GB" "INFO"  | indent10
    else
        # print and format output
        sp="${frame}|${bodytext}"       # separator

        if (( $(tput cols) >= "172" )); then
            FULL_CLI="True"
            std_logger "[INFO]: FULL_CLI set to True, Full width output"
            total_width="169"
        else
            total_width="143"
        fi

        # retrieve account name
        ACCT_ALIAS="$(account_alias $PROFILE)"

        # snapshots found, print region identifier
        printf -- '\n%128s\t%18s%105s\n' "${title}SECURITY GROUPS${bodytext} :  ${regions}$REGION${bodytext}" "$sp" "${title}ACCOUNT${bodytext} : ${account}$ACCT_ALIAS${bodytext}"

        if [ $FULL_CLI ]; then
            print_header "$sp  GroupName $sp GroupId $sp Ports $sp Ports $sp CidrIp $sp VpcId $sp Tag $sp Description $sp" $total_width  $TMPDIR/.ec2-qv-securitygroups.tmp
        else
            print_header "$sp  GroupName $sp GroupId $sp Ports $sp Ports $sp CidrIp $sp VpcId $sp Tag $sp" $total_width  $TMPDIR/.ec2-qv-securitygroups.tmp
        fi

        # parse json
        ARR_ID=( $(jq -r '.SecurityGroups[].GroupId' $TMPDIR/.jsonoutput.tmp) )
        ARR_NAME=( $(jq -r '.SecurityGroups[].GroupName' $TMPDIR/.jsonoutput.tmp) )
        ARR_FPORT=( $(jq -r '.SecurityGroups[].IpPermissions[0].FromPort' $TMPDIR/.jsonoutput.tmp) )
        ARR_TPORT=( $(jq -r '.SecurityGroups[].IpPermissions[0].ToPort' $TMPDIR/.jsonoutput.tmp) )
        ARR_CIDR=( $(jq -r '.SecurityGroups[].IpPermissions[0].IpRanges[0].CidrIp' $TMPDIR/.jsonoutput.tmp) )
        ARR_VPC=( $(jq -r '.SecurityGroups[].VpcId' $TMPDIR/.jsonoutput.tmp) )
        ARR_TAGKEY=( $(jq -r '.SecurityGroups[].Tags[0].Key' $TMPDIR/.jsonoutput.tmp) )
        ARR_TAGVALUE=( $(jq -r '.SecurityGroups[].Tags[0].Value' $TMPDIR/.jsonoutput.tmp) )
        ARR_DESC=( $(jq -r '.SecurityGroups[].Description' $TMPDIR/.jsonoutput.tmp) )

        # ip stats
        MAXCT=${#ARR_ID[*]}    # count snapshots found
        SUM_OPEN=0; SUM_P22=0; SUM_P80=0; SUM_32=0
        for record in ${ARR_CIDR[@]}; do
            if [ $(echo "$record" | grep "0.0.0.0") ]; then
                SUM_OPEN=$(( $SUM_OPEN + 1))
            elif [ $(echo $record | grep '/32') ]; then
                SUM_32=$(( $SUM_32 + 1))
            fi
        done
        i=0
        for record in ${ARR_FPORT[@]}; do
            if [ "${ARR_FPORT[$i]}" = "80" ] || [ "${ARR_TPORT[$i]}" = "80" ]; then
                SUM_P80=$(( $SUM_P80 + 1))
            elif [ "${ARR_FPORT[$i]}" = "22" ] || [ "${ARR_TPORT[$i]}" = "22" ]; then
                SUM_P22=$(( $SUM_P22 + 1))
            fi
            i=$(( $i + 1 ))
        done

        # output table of json array
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_NAME[$i]} $sp ${ARR_ID[$i]} $sp "$( if [ $(echo ${ARR_FPORT[$i]}) = "null" ]; then echo "-"; else echo "${ARR_FPORT[$i]}"; fi )" \
                      $sp "$( if [ $(echo ${ARR_TPORT[$i]}) = "null" ]; then echo "-"; else echo "${ARR_TPORT[$i]}"; fi )"  \
                      $sp "$( if [ $(echo ${ARR_CIDR[$i]}) = "null" ]; then echo "-"; else echo "${ARR_CIDR[$i]}"; fi )" $sp ${ARR_VPC[$i]} \
                      $sp "$( if [ $(echo ${ARR_TAGKEY[$i]}) = "null" ]; then echo "-"; else echo "${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]}"; fi )"  \
                      $sp ${ARR_DESC[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        else
            while (( i < $MAXCT )); do
                while (( i < $MAXCT )); do
                    echo "$sp ${ARR_NAME[$i]} $sp ${ARR_ID[$i]} $sp "$( if [ $(echo ${ARR_FPORT[$i]}) = "null" ]; then echo "-"; else echo "${ARR_FPORT[$i]}"; fi )" \
                          $sp "$( if [ $(echo ${ARR_TPORT[$i]}) = "null" ]; then echo "-"; else echo "${ARR_TPORT[$i]}"; fi )" \
                          $sp "$( if [ $(echo ${ARR_CIDR[$i]}) = "null" ]; then echo "-"; else echo "${ARR_CIDR[$i]}"; fi )" $sp ${ARR_VPC[$i]} \
                          $sp "$( if [ $(echo ${ARR_TAGKEY[$i]}) = "null" ]; then echo "-"; else echo "${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]}"; fi )" $sp" >> $TMPDIR/.body.tmp
                    # incr ct
                    i=$(( $i+1 ))
                done
            done
        fi

        # sort
        cat $TMPDIR/.body.tmp | sort -k2 -r >> $TMPDIR/.ec2-qv-securitygroups.tmp

        if [ $FULL_CLI ]; then
            # print and format output
            awk '{ printf "%-2s %-27.27s %-2s %-21s %-2s %-5s %-2s %-5s %-2s %-19s %-2s %-13s %-2s %-29.29s %-2s %-26.26s %-2s \n", \
                    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' $TMPDIR/.ec2-qv-securitygroups.tmp | indent02
        else
            awk '{ printf "%-2s %-26.26s %-2s %-21s %-2s %-6s %-2s %-7s %-2s %-19s %-2s %-13s %-2s %-29.29s %-2s \n", \
                    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15}' $TMPDIR/.ec2-qv-securitygroups.tmp | indent02
        fi
        # print footer
        print_footer "${title}$SUM${bodytext} Security Groups in region [$REGION]
        \n\n     Group Summary:\n\n\t\tOpen (0.0.0.0):\t\t ${title}$SUM_OPEN${bodytext}\n
        \t\tPort 80:\t\t ${title}$SUM_P80${bodytext}${bodytext}\n
        \t\tPort 22:\t\t ${title}$SUM_P22${bodytext}\n
        \t\tRestricted (/32):\t ${title}$SUM_32${bodytext}\n" $total_width

        # clean up
        rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.body.tmp  $TMPDIR/.ec2-qv-securitygroups.tmp
    fi
    #
    # <-- end function ec2cli_list_securitygroups -->
    #
}


function ec2cli_list_snapshots(){
    # vars
    local REGION=$1
    local sort_column="$2"
    local export="$3"
    local choice
    local path
    local SUM
    local TOTAL
    local total_width=$(( $(tput cols) - 4 ))

    if [ "$export" = "true" ]; then
        echo -e "\nExport Data to Comma Separated Value Format -- ${title}Snapshots${bodytext}\n" | indent04
        read -p "    Export File Location? [ $pwd ]: " choice | indent04
        if [ -z $choice ]; then
            path="$pwd"
        elif [ "$choice" = "q" ]; then
            return 0
        else
            path="$choice"
        fi
        std_message "Exporting snapshot data to comma separated value (csv) file." "INFO" | indent04
        python3 $lib_path/csv_generator.py --profile $PROFILE --type snapshots --region $REGION --filepath $path
        return 0
    fi
    #
    # pull json info, all instances in region
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE" | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-snapshots --owner self \
                --region $region --output json >> $TMPDIR/.jsonoutput.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-snapshots --owner self \
                    --output json --region $REGION > $TMPDIR/.jsonoutput.tmp
    fi

    # retrieve account name
    ACCT_ALIAS="$(account_alias $PROFILE)"

    # Sum size of all snapshots (footer)
    if [ $ALL_REGIONS ]; then
        SUM=0
        ARR=$(cat $TMPDIR/.jsonoutput.tmp | jq -r .Snapshots[].VolumeSize)
        for vol in ${ARR[@]}; do
            SUM=$(( $SUM + $vol ))
        done
    else
        SUM=$(jq -r '.Snapshots | map(.VolumeSize) | add' $TMPDIR/.jsonoutput.tmp)
    fi

    if [ "$SUM" = "null" ] || [ "$SUM" -eq 0 ]
    then
        # print footer if no snapshots found
        std_message "${title}0${bodytext} snapshots in region [$REGION], total ${title}0${bodytext} GB" "INFO"  | indent10
    else
        # print and format output
        sp="${frame}|${bodytext}"       # separator

        if (( $(tput cols) >= "170" )); then
            FULL_CLI="True"
            std_logger "[INFO]: FULL_CLI set to True, Full width output"
            total_width="170"
        else
            total_width="142"
        fi
        # snapshots found, print region identifier
        printf "\n${title}SNAPSHOTS${bodytext} : $REGION\t$sp\t${title}ACCOUNT${bodytext} : ${account}$ACCT_ALIAS${bodytext}\n" | indent25

        if [ $FULL_CLI ]; then
            print_header "$sp  SnapId $sp Size $sp CreateTime* $sp State $sp Prog $sp Encrypted $sp VolumeId $sp Tag $sp Description $sp" $total_width  $TMPDIR/.ec2-qv-snapshots.tmp
        else
            print_header "$sp SnapId $sp Size $sp CreateTime* $sp State $sp Prog $sp Encrypted $sp VolumeId $sp Description $sp" $total_width $TMPDIR/.ec2-qv-snapshots.tmp
        fi

        # parse json
        ARR_ID=( $(jq -r '.Snapshots[].SnapshotId' $TMPDIR/.jsonoutput.tmp) )
        ARR_SIZE=( $(jq -r '.Snapshots[].VolumeSize' $TMPDIR/.jsonoutput.tmp) )
        ARR_CTIME=( $(jq -r '.Snapshots[].StartTime' $TMPDIR/.jsonoutput.tmp) )
        ARR_VID=( $(jq -r '.Snapshots[].VolumeId' $TMPDIR/.jsonoutput.tmp) )
        ARR_STATE=( $(jq -r '.Snapshots[].State' $TMPDIR/.jsonoutput.tmp) )
        ARR_PROG=( $(jq -r '.Snapshots[].Progress' $TMPDIR/.jsonoutput.tmp) )
        ARR_ENCRYPT=( $(jq -r '.Snapshots[].Encrypted' $TMPDIR/.jsonoutput.tmp) )
        ARR_DESC=( $(jq -r '.Snapshots[].Description' $TMPDIR/.jsonoutput.tmp | cut -c 1-37) )
        # limit length of tag fields to 20 chars
        ARR_TAGKEY=( $(jq -r '.Snapshots[].Tags[0].Key' $TMPDIR/.jsonoutput.tmp | cut -c 1-15) )
        ARR_TAGVALUE=( $(jq -r '.Snapshots[].Tags[0].Value' $TMPDIR/.jsonoutput.tmp | cut -c 1-15) )

        MAXCT=${#ARR_ID[*]}    # count snapshots found

        # output table of json array
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_PROG[$i]} $sp $( if $(echo ${ARR_ENCRYPT[$i]}) == "true"; then echo "Encypt"; else echo "-"; fi ) $sp \
                      ${ARR_VID[$i]} $sp ${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]} $sp ${ARR_DESC[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        else
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_PROG[$i]} $sp $( if $(echo ${ARR_ENCRYPT[$i]}) == "true"; then echo "Encrypted"; else echo "-"; fi ) $sp \
                      ${ARR_VID[$i]} $sp ${ARR_DESC[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        fi

        if [ ! $sort_column ]; then
            sort_column="date"
        fi
        case $sort_column in
            id | Id | ID | SnapshotId)
                column=2; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv-snapshots.tmp;;
            size | Size)
                column=4; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv-snapshots.tmp;;
            date)
                column=5; cat $TMPDIR/.body.tmp | sort -k6 -r >> $TMPDIR/.ec2-qv-snapshots.tmp;;
        esac

        # size, unit calcs of raw volumes snapshotted
        RETURN=$(adjust_units $SUM)
        ASUM=$(echo $RETURN | awk '{print $1}')
        UNIT=$(echo $RETURN | awk '{print $2}')
        # estimated actual size, units on disk
        ESTIMATE="$(( $SUM / 5 ))"    # 20% estimated real size on disk
        RETURN=$(adjust_units $ESTIMATE)
        ESUM="${BOLD}$(echo $RETURN | awk '{print $1}')${UNBOLD}"
        EUNIT=$(echo $RETURN | awk '{print $2}')
        if [ $FULL_CLI ]; then
            awk  '{printf "%-2s %-23s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-5s %-2s %-9s %-2s %-22s %-2s %-30.29s %-2s %-26s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19}' $TMPDIR/.ec2-qv-snapshots.tmp | indent02
        else
            awk  '{printf "%-2s %-23s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-5s %-2s %-10s %-2s %-22s %-2s %-30.29s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' $TMPDIR/.ec2-qv-snapshots.tmp | indent02
        fi
        # print footer
        if [ $ALL_REGIONS ]; then
            print_footer "${title}$MAXCT${UNBOLD}${bodytext} snapshots acorss ${title}$REGION_CT${bodytext} regions, total ${title}$ASUM${UNBOLD}${bodytext} $UNIT | ${title}$ESUM${UNBOLD}${bodytext} $EUNIT on disk (est, $ast*${bodytext}sorted)" $total_width
        else
            print_footer "${title}$MAXCT${UNBOLD}${bodytext} snapshots in region [$REGION], total ${title}$ASUM${UNBOLD}${bodytext} $UNIT | ${title}$ESUM${UNBOLD}${bodytext} $EUNIT on disk (est, $ast*${bodytext}sorted)" $total_width
        fi
        rm $TMPDIR/.ec2-qv-snapshots.tmp $TMPDIR/.body.tmp $TMPDIR/.jsonoutput.tmp
    fi
    #
    # <-- end function ec2cli_list_snapshots -->
    #
}


function ec2cli_list_subnets(){
    # vars
    local TOTAL
    local REGION=$1

    # pull json info, all instances in region
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE" | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-subnets \
                --region $region --output json >> $TMPDIR/.jsonoutput.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-subnets --output json --region $REGION > $TMPDIR/.jsonoutput.tmp
    fi

    # number of groups
    SUM=$(jq -r '.Subnets[].CidrBlock' $TMPDIR/.jsonoutput.tmp | wc -l)


    if [ "$SUM" = "null" ] || [ "$SUM" -eq 0 ]; then
        # print footer if no snapshots found
        std_message "${title}0${bodytext} subnets in region [$REGION]" "INFO"  | indent10
    else
        # print and format output
        sp="${frame}|${bodytext}"       # separator

        if (( $(tput cols) >= "168" )); then
            FULL_CLI="True"
            std_logger "[INFO]: FULL_CLI set to True, Full width output"
            total_width="163"
        else
            total_width="120"
        fi

        # retrieve account name
        ACCT_ALIAS="$(account_alias $PROFILE)"

        # subnets found, print region identifier
        printf "\n${title}SUBNETS${bodytext} : $REGION\t$sp\t${title}ACCOUNT${bodytext} : ${account}$ACCT_ALIAS${bodytext}\n" | indent25

        if [ $FULL_CLI ]; then
            print_header "$sp  Name $sp SubnetId $sp Public $sp CIDR-Block $sp IPs $sp AvailZone $sp Default $sp TagKey:Value" $total_width  $TMPDIR/.ec2-qv.tmp
        else
            print_header "$sp  Name $sp SubnetId $sp Public $sp CIDR-Block $sp IPs $sp AvailZone $sp Default $sp" $total_width  $TMPDIR/.ec2-qv.tmp
        fi

        # parse json
        ARR_NAME=( $(jq -r '.Subnets[].Tags[0].Value' $TMPDIR/.jsonoutput.tmp) )
        ARR_ID=( $(jq -r '.Subnets[].SubnetId' $TMPDIR/.jsonoutput.tmp) )
        ARR_MAP=( $(jq -r '.Subnets[].MapPublicIpOnLaunch' $TMPDIR/.jsonoutput.tmp) )
        ARR_CIDR=( $(jq -r '.Subnets[].CidrBlock' $TMPDIR/.jsonoutput.tmp) )
        ARR_CT=( $(jq -r '.Subnets[].AvailableIpAddressCount' $TMPDIR/.jsonoutput.tmp) )
        ARR_AZ=( $(jq -r '.Subnets[].AvailabilityZone' $TMPDIR/.jsonoutput.tmp) )
        ARR_DEFAULT=( $(jq -r '.Subnets[].DefaultForAz' $TMPDIR/.jsonoutput.tmp) )
        ARR_TAGKEY=( $(jq -r '.Subnets[].Tags[1].Key' $TMPDIR/.jsonoutput.tmp) )
        ARR_TAGVALUE=( $(jq -r '.Subnets[].Tags[1].Value' $TMPDIR/.jsonoutput.tmp) )


        MAXCT=${#ARR_ID[*]}    # count snapshots found

        # output table of json array
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp $(if [ "${ARR_NAME[$i]}" = "null" ]; then echo "-"; else echo "${ARR_NAME[$i]}"; fi) \
                      $sp ${ARR_ID[$i]} $sp ${ARR_MAP[$i]} $sp ${ARR_CIDR[$i]} $sp ${ARR_CT[$i]}  \
                      $sp ${ARR_AZ[$i]} $sp "$( if $(echo ${ARR_DEFAULT[$i]}) == "true"; then echo "yes"; else echo "-"; fi )" \
                      $sp $(if [ "${ARR_TAGKEY[$i]}" = "null" ]; then echo "-"; else echo "${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]}"; fi) \
                      $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        else
            while (( i < $MAXCT )); do
                echo "$sp $(if [ "${ARR_NAME[$i]}" = "null" ]; then echo "-"; else echo "${ARR_NAME[$i]}"; fi) \
                      $sp ${ARR_ID[$i]} $sp ${ARR_MAP[$i]} $sp ${ARR_CIDR[$i]} $sp ${ARR_CT[$i]}  \
                      $sp ${ARR_AZ[$i]} $sp "$( if $(echo ${ARR_DEFAULT[$i]}) == "true"; then echo "yes"; else echo "-"; fi )" \
                      $sp " >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        fi

        if [ ! $sort_column ]; then
            sort_column="ID"
        fi
        case $sort_column in
            id | Id | ID | SnapshotId)
                column=4; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv.tmp;;
            ip | IPs | ips | num_ip)
                column=10; cat $TMPDIR/.body.tmp | sort -k"$column" -r -n >> $TMPDIR/.ec2-qv.tmp;;
            date)
                column=5; cat $TMPDIR/.body.tmp | sort -k6 -r >> $TMPDIR/.ec2-qv.tmp;;
        esac

        if [ $FULL_CLI ]; then
            awk  '{printf "%-2s %-25.24s %-2s %-16s %-2s %-7s %-12s %-19s %-2s %-7s %-2s %-15s %-2s %-9.8s %-2s %-40.39s %-2s\n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' $TMPDIR/.ec2-qv.tmp | indent02
        else
            awk  '{printf "%-2s %-25.24s %-2s %-16s %-2s %-7s %-12s %-19s %-2s %-7s %-2s %-15s %-2s %-9.8s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15}' $TMPDIR/.ec2-qv.tmp | indent02
        fi
        # print footer
        if [ $ALL_REGIONS ]; then
            print_footer "${title}$MAXCT${bodytext} subnets across ${title}$REGION_CT${bodytext} regions" $total_width
        else
            print_footer "${title}$MAXCT${bodytext} subnets in region [$REGION]" $total_width
        fi

        # clean up
        rm $TMPDIR/.jsonoutput.tmp $TMPDIR/.ec2-qv.tmp $TMPDIR/.body.tmp
    fi
    #
    # <-- end function ec2cli_list_subnets -->
    #
}


function ec2cli_list_tags(){
    # vars
    local region="$1"
    local resource_id="$2"

    if [ "$resource_id" = "??-*-[1-9]" ]; then
        resource_id="$1"
        region="$2"
    fi
    if [ ! "$resource_id" ]; then
        echo " "
        aws ec2 --profile $PROFILE describe-tags --output table
        echo " "
    else
        # resource ID given by user
        tags=""
        tags=$(aws ec2 --profile $PROFILE describe-tags \
                --filters="Name=resource-id,Values=$resource_id" \
                --region $region \
                --output json | grep $resource_id)
        if [[ ! $tags ]]; then
            # no tags exist for resource
            std_message "No tags found for resource [$resource_id]." INFO
            echo -e "  ${BOLD}NOTE${UNBOLD}:   You must provide a regioncode if the resource is not" | indent04
            echo -e "    in your default region.\n" | indent10
        else
            echo -e "\nTags for AWS ResourceId:  ${title}$resource_id${reset} | ${blue_frame}$region${reset}\n" | indent15
            aws ec2 --profile $PROFILE describe-tags \
                --filters="Name=resource-id,Values=$resource_id" \
                --region $region \
                --output table
            echo -e "\n"
        fi
    fi
    #
    # <-- end function ec2cli_list_tags -->
    #
}


function ec2cli_list_volumes(){
    # vars
    local REGION=$1
    local sort_column="$2"                      # column to use when sorting all fields
    local SUM
    local TOTAL
    local total_width
    local sp="${frame}|${bodytext}"       # separator
    #
    # determine output size
    if (( $(tput cols) >= "172" )); then
        FULL_CLI="True"
        total_width="170"
    elif (( $(tput cols) >= "134" )); then
        MED_CLI="True"
        std_logger "[INFO]: MED_CLI set to True, Full width output"
        total_width="129"
    else
        total_width="111"
    fi
    # sum total size of all volumes (display in footer)
    # pull json info, all instances in region
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE" | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-volumes \
                --region $region --output json >> $TMPDIR/.jsonoutput.tmp; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-volumes --region $REGION --output json > $TMPDIR/.jsonoutput.tmp
    fi

    # determine size of all volumes returned
    if [ $ALL_REGIONS ]; then
        SUM=0
        ARR=$(jq -r '.Volumes[].Size' $TMPDIR/.jsonoutput.tmp);
        for vol in ${ARR[@]}; do
            SUM=$(( $SUM + $vol ))
        done
    else
        SUM=$(jq -r '.Volumes | map(.Size) | add' $TMPDIR/.jsonoutput.tmp)
    fi
    if [ "$SUM" = "null" ] || [ "$SUM" -eq 0 ]
    then
        # print footer if no volumes found
        std_message "${title}0${bodytext} volumes in region [$REGION], total ${title}${BOLD}0${bodytext} GB" "INFO"
    else
        #
        # volumes found, print region identifier
        #
        printf "\n${title}EBS VOLUMES${bodytext} : $REGION   |  *sorted\n" | indent18

        # parse json
        ARR_VID=( $(jq -r '.Volumes[].VolumeId' $TMPDIR/.jsonoutput.tmp) )
        ARR_SIZE=( $(jq -r '.Volumes[].Size' $TMPDIR/.jsonoutput.tmp) )
        ARR_CTIME=( $(jq -r '.Volumes[].CreateTime' $TMPDIR/.jsonoutput.tmp) )
        ARR_STATE=( $(jq -r '.Volumes[].Attachments[0].State' $TMPDIR/.jsonoutput.tmp) )
        ARR_ENCRYPT=( $(jq -r '.Volumes[].Encrypted' $TMPDIR/.jsonoutput.tmp) )
        ARR_IID=( $(jq -r '.Volumes[].Attachments[0].InstanceId' $TMPDIR/.jsonoutput.tmp) )
        ARR_VTYPE=( $(jq -r '.Volumes[].VolumeType' $TMPDIR/.jsonoutput.tmp) )
        ARR_AZ=( $(jq -r '.Volumes[].AvailabilityZone' $TMPDIR/.jsonoutput.tmp | cut -c 1-20) )
        # limit length of tag fields to 20 chars
        ARR_TAGKEY=( $(jq -r '.Volumes[].Tags[0].Key' $TMPDIR/.jsonoutput.tmp | cut -c 1-20) )
        ARR_TAGVALUE=( $(jq -r '.Volumes[].Tags[0].Value' $TMPDIR/.jsonoutput.tmp | cut -c 1-20) )

        MAXCT=${#ARR_VID[*]}    # count snapshots found
        UNATTACHED_CT="0"
        for entry in ${ARR_STATE[@]}; do
            if [ "$entry" = "null" ]; then UNATTACHED_CT=$(( $UNATTACHED_CT + 1 )); fi
        done
        # print and format output
        i=0
        if [ $FULL_CLI ]; then
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      $( if [ "${ARR_STATE[$i]}" = "null" ]; then echo "free"; else echo "${ARR_STATE[$i]}"; fi ) $sp \
                      $( if [ "${ARR_ENCRYPT[$i]}" = "true" ]; then echo "Encypt"; else echo "-"; fi ) $sp \
                      $( if [ "${ARR_IID[$i]}" = "null" ]; then echo "-"; else echo "${ARR_IID[$i]}"; fi ) $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_AZ[$i]} $sp "${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]}" $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Encrypted $sp InstanceId $sp VolType $sp Avail-Zone $sp Tag $sp" $total_width $TMPDIR/.ec2-qv-volumes.tmp
            # sort body text
            if [ ! $sort_column ]; then
                sort_column="date"
            fi
            case $sort_column in
                id | Id | ID)
                    column=2; cat $TMPDIR/.body.tmp | sort -k"$column" >> $TMPDIR/.ec2-qv-volumes.tmp;;
                size | Size)
                    column=4; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv-volumes.tmp;;
                date)
                    column=6; cat $TMPDIR/.body.tmp | sort -k"$column" -r >> $TMPDIR/.ec2-qv-volumes.tmp;;
            esac
            awk  '{ printf "%-2s %-22s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-9s %-2s %-20s %-2s %-8s %-2s %-15s %-2s %-41s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19}' $TMPDIR/.ec2-qv-volumes.tmp | indent02

        elif [ $MED_CLI ]; then
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      $( if [ "${ARR_STATE[$i]}" = "null" ]; then echo "free"; else echo "${ARR_STATE[$i]}"; fi ) $sp \
                      $( if [ "${ARR_ENCRYPT[$i]}" = "true" ]; then echo "Encypt"; else echo "-"; fi ) $sp \
                      $( if [ "${ARR_IID[$i]}" = "null" ]; then echo "-"; else echo "${ARR_IID[$i]}"; fi ) $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_AZ[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Encrypted $sp InstanceId $sp VolType $sp Avail-Zone $sp" $total_width $TMPDIR/.ec2-qv-volumes.tmp
            # sort body text
            if [ ! $sort_column ]; then
                sort_column="date"
            fi
            case $sort_column in
                id | Id | ID)
                    column=2; cat $TMPDIR/.body.tmp | sort -k"$column" >> $TMPDIR/.ec2-qv-volumes.tmp;;
                size | Size)
                    column=4; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv-volumes.tmp;;
                date)
                    column=6; cat $TMPDIR/.body.tmp | sort -k"$column" -r >> $TMPDIR/.ec2-qv-volumes.tmp;;
            esac
            awk  '{ printf "%-2s %-22s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-10s %-2s %-20s %-2s %-9s %-2s %-16s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' $TMPDIR/.ec2-qv-volumes.tmp | indent02
        else
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      $( if [ "${ARR_STATE[$i]}" = "null" ]; then echo "free"; else echo "${ARR_STATE[$i]}"; fi ) $sp \
                      $( if [ "${ARR_ENCRYPT[$i]}" = "true" ]; then echo "Encypt"; else echo "-"; fi ) $sp \
                      $( if [ "${ARR_IID[$i]}" = "null" ]; then echo "-"; else echo "${ARR_IID[$i]}"; fi ) $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_TAG[$i]} $sp" >> $TMPDIR/.body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Encrypted $sp InstanceId $sp VolType $sp" $total_width $TMPDIR/.ec2-qv-volumes.tmp
            # sort body text
            if [ ! $sort_column ]; then
                sort_column="date"
            fi
            case $sort_column in
                id | Id | ID)
                    column=2; cat $TMPDIR/.body.tmp | sort -k"$column" >> $TMPDIR/.ec2-qv-volumes.tmp;;
                size | Size)
                    column=4; cat $TMPDIR/.body.tmp | sort -k"$column" -n >> $TMPDIR/.ec2-qv-volumes.tmp;;
                date)
                    column=6; cat $TMPDIR/.body.tmp | sort -k"$column" -r >> $TMPDIR/.ec2-qv-volumes.tmp;;
            esac
            awk  '{ printf "%-2s %-22s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-10s %-2s %-20s %-2s %-10s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' $TMPDIR/.ec2-qv-volumes.tmp | indent02
        fi
        # size, unit calcs of raw volumes
        RETURN=$(adjust_units $SUM)
        ASUM=$(echo $RETURN | awk '{print $1}')
        UNIT=$(echo $RETURN | awk '{print $2}')
        # print footer
        print_footer "${title}$MAXCT${bodytext} volumes in region [$REGION], ${title}$UNATTACHED_CT${bodytext} unattached to instances (free). \
        Total size on disk ${title}$ASUM${bodytext} $UNIT" $total_width

        # clean up
        rm $TMPDIR/.ec2-qv-volumes.tmp $TMPDIR/.body.tmp $TMPDIR/.jsonoutput.tmp
    fi
    #
    # <-- end function ec2cli_list_volumes -->
    #
}


function ec2cli_list_vpcs(){
    # vars
    local region="$1"
    local total_width="133"
    local sp="${frame}|${bodytext}"       # separator

    # output from aws
    # pull json info, all instances in region
    if [ $ALL_REGIONS ]; then
        # load array from local list of regions
        REGIONS=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE")
        REGION_CT=$(cat "$CONFIG_PATH/$REGION_CONFIGFILE" | wc -l)
        for region in ${REGIONS[@]}; do \
            aws ec2 --profile $PROFILE describe-vpcs \
                --region $region --output json >> .jsonoutput.json; done &
        delay_spinner "  Please wait, retrieving data from AWS..."
        clear
    else
        aws ec2 --profile $PROFILE describe-vpcs --output json --region $REGION > .jsonoutput.json
    fi
    # parse json
    ARR_ID=( $(jq -r '.Vpcs[].VpcId' .jsonoutput.json) )
    ARR_DEFAULT=( $(jq -r '.Vpcs[].IsDefault' .jsonoutput.json) )
    ARR_STATE=( $(jq -r '.Vpcs[].State' .jsonoutput.json) )
    ARR_TENANCY=( $(jq -r '.Vpcs[].InstanceTenancy' .jsonoutput.json) )
    ARR_CIDR=( $(jq -r '.Vpcs[].CidrBlock' .jsonoutput.json) )
    ARR_DHCP=( $(jq -r '.Vpcs[].DhcpOptionsId' .jsonoutput.json) )
    ARR_TAGKEY=( $(jq -r '.Vpcs[].Tags[0].Key' .jsonoutput.json | cut -c 1-18) )
    ARR_TAGVALUE=( $(jq -r '.Vpcs[].Tags[0].Value' .jsonoutput.json | cut -c 1-18) )
    MAXCT=${#ARR_ID[*]}    # count snapshots found
    # output table of json array
    i=0
    while (( i < $MAXCT )); do
        echo "$sp ${ARR_ID[$i]} $sp $(if [ "${ARR_DEFAULT[$i]}" = "true" ]; then echo "yes"; else echo "-"; fi) $sp ${ARR_STATE[$i]} $sp \
              ${ARR_TENANCY[$i]} $sp ${ARR_CIDR[$i]} $sp ${ARR_DHCP[$i]} $sp \
              ${ARR_TAGKEY[$i]}:${ARR_TAGVALUE[$i]} $sp" >> $TMPDIR/.body.tmp
        # incr ct
        i=$(( $i+1 ))
    done
    # print region identifier
    printf "\n${title}Virtual Private Clouds (VPC)${bodytext} : $REGION\n" | indent18
    # print header
    print_header "VpcId State Tenancy CIDR-Block Default" $total_width .report.tmp

    # print header
    print_header "$sp VpcId $sp Default? $sp State $sp Tenancy $sp CIDR $sp DHCP-OptionId $sp Tags $sp" $total_width .report.tmp
    # sort body text
    cat $TMPDIR/.body.tmp | sort -k +10n  >> $TMPDIR/.report.tmp
    # print and format output
    awk  '{ printf "%-2s %-14s %-2s %-8s %-2s %-10s %-2s %-9s %-2s %-16s %-2s %-15s %-2s %-39s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15}' .report.tmp | indent02
    # print footer
    if [ $ALL_REGIONS ]; then
        print_footer "${title}$MAXCT${bodytext} VPCs across ${title}$REGION_CT${bodytext} regions" $total_width
    else
        print_footer "${title}$MAXCT${bodytext} VPCs in region [$REGION]" $total_width
    fi
    # clean up
    rm .jsonoutput.json $TMPDIR/.body.tmp $TMPDIR/.report.tmp
    #
    # <-- end function ec2cli_list_vpcs -->
    #
}


function setup_regioncodes(){
    ## writeout region codes to config file, every REFRESH_REGIONCODES freq ##
    local age
    local mtime
    local allowable_age_secs
    local recreate_flag
    local now=$(date -u +%s)
    local regioncodes="$CONFIG_PATH/$REGION_CONFIGFILE"
    local num_codes="$(cat $regioncodes 2>/dev/null | wc -l)"
    #
    std_logger "[INFO]: Validating existence of "$CONFIG_PATH/$REGION_CONFIGFILE""
    if [ -f "$CONFIG_PATH/$REGION_CONFIGFILE" ]; then
        # check file age
        mtime=$(stat -c %Y $CONFIG_PATH/$REGION_CONFIGFILE)
        age=$(( $now - $mtime ))
        allowable_age_secs=$(( $REFRESH_REGIONCODES * 24 * 60 * 60 ))
        # check age and correct number of regions present
        if [ $age -gt $allowable_age_secs ] || [ "$num_codes" -lt "10" ]; then
            # refresh region codes
            std_logger "[INFO]: Regioncode file age: $(( $age / 24 / 60 / 60 )) days"
            std_logger "[INFO]: Allowable file age: $REFRESH_REGIONCODES days"
            std_logger "[INFO]: Refresh region codes set to True"
            recreate_flag="true"
        fi
        std_logger "[INFO]: Region code config file ($regioncodes) found, age $(($age/24/60/60)) days"
        std_logger "[INFO]: $(cat $regioncodes | wc -l) Regions identified"
    elif [ "$num_codes" -lt "14" ]; then
        recreate_flag="true"
    fi

    if [ ! -f "$CONFIG_PATH/$REGION_CONFIGFILE" ] || [ "$recreate_flag" ]; then
        std_logger "[INFO]: (re)creating REGION_CONFIGFILE ($CONFIG_PATH/$REGION_CONFIGFILE)"
        # verify authentication using default profile
        if authenticated $PROFILE; then
            JSON_REGIONS=$(aws ec2 --profile $PROFILE describe-regions --output json)
            echo $JSON_REGIONS | jq -r .Regions[].RegionName > "$CONFIG_PATH/$REGION_CONFIGFILE"
        else
            cp $lib_path/regions.list "$CONFIG_PATH/$REGION_CONFIGFILE"
        fi
    fi
    REGIONFILE_CHECK="true"
    return 0
}


function parse_regioncode(){
    ## retrieve codes for all valid AWS Regions globally ##
    user_provided="$1"
    #
    case $user_provided in
        -p | --profile | -d | --debug | -h | --help)
            return 1
            ;;

        attach | create | list | run)
            return 0
            ;;
    esac

    if [ ! $REGIONFILE_CHECK ]; then setup_regioncodes; fi

    # parameter is a region, validate it
    if [ "$(grep $user_provided "$CONFIG_PATH/$REGION_CONFIGFILE")" ]; then
        # aws region given
        return 0
    else
        # bad regioncode
        std_error_exit "Invalid AWS region code [ $1 ]. See ec2cli --help. Exiting (code $E_BADARG)" $E_BADARG
    fi
    #
    # <-- end function parse_regioncode -->
}


function parse_command(){
    COMMAND="$1"
    #
    std_logger "[INFO]: parse_command: COMMAND parameter received is ($COMMAND)"
    # check if command is a region code
    if [[ $COMMAND = ??-*-[1-9] ]]; then
        # region code given instead
        # user requests default (list)
        parse_regioncode $COMMAND
        COMMAND="list"    # set to default, no command given
        return
    elif [[ $COMMAND = i-* ]] || [[ $COMMAND = subnet-* ]] || [[ $COMMAND = vpc-* ]] \
        || [[ $COMMAND = ami-* ]] || [[ $COMMAND = sg-* ]] || [[ $COMMAND = snap-* ]]  \
        || [[ $COMMAND = vol-* ]]; then
        # resource id given instead of a command
        RESOURCEID=$COMMAND
        COMMAND="list"    # set to default, resource-id given instead of command
        return
    elif [ "$COMMAND" == "--all" ]; then
        "ALL_REGIONS"="true"
        COMMAND="list"
        return
    elif [ ! $COMMAND ]; then
        # command blank
        std_warn "You must provide a command"
        exit $E_DEPENDENCY
    else
        case $COMMAND in
            attach | Attach | ATTACH)
                COMMAND="attach"
                ;;
            list | List | LIST)
                COMMAND="list"
                ;;
            create | Create | CREATE)
                COMMAND="create"
                ;;
            run | Run | RUN | ru | r | start | Start)
                COMMAND="run"
                ;;
            *)
                std_logger "[WARN]: Not a recognized COMMAND ($COMMAND), assume default COMMAND"
                COMMAND="list"
                return 1
                ;;
        esac
    fi
    #
    # <-- end function parse_command -->
}


function set_default_region(){
    ## finds out default region ##
    profile_name="$1"
    #
    awscli=$(which aws)
    DEFAULT_REGION=$($awscli configure get $profile_name.region)
    if [ ! $DEFAULT_REGION ]; then
        if [ $AWS_DEFAULT_REGION ]; then
            DEFAULT_REGION=$AWS_DEFAULT_REGION
        elif [ ! $AWS_DEFAULT_REGION ]; then
            std_error_exit "You must enter an AWS regioncode -- A default region was not found in your user profile. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    std_logger "[INFO]: DEFAULT_REGION identified as:  $DEFAULT_REGION"
}


function set_profile(){
    local profilename="$1"
    if [ $profilename ]; then
        PROFILE=$profilename
    else
        std_warn "You must provide a profile name when using -p / --profile parameter"
    fi
}


function parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        ec2cli_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --h | -help | --help)
                    # display help
                    ec2cli_help
                    exit 0
                    ;;
                -d | --debug | --dbug)
                    ## enable verbose logging and output ##
                    DBUGMODE="True"
                    std_logger "[INFO]: DBUGMODE enabled, set to True"
                    shift 1
                    ;;
                -p | --profile)
                    if [ $2 ]; then
                        PROFILE="$(profilename_prefix $2)"
                    else
                        std_warn "You must provide a profile name when using --profile parameter"
                    fi
                    shift 2
                    ;;
                -A | --all)
                    ALL_REGIONS="true"
                    shift 1
                    ;;
                -a | --images | --ami)
                    #
                    # display details of Amazon Machine Images for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_images"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_images"
                                ;;
                            attach | run)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -b | -subnets | --subnet | --subnets)
                    #
                    # display details of all regional vpc subnets
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_subnets"
                                ;;
                            attach | create | run)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -g | --secgroups | --securitygroups)
                    #
                    # display details of EC2 security groups for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_securitygroups"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -i | --instances)
                    #
                    # display instances details for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="ec2cli_help_command_list_instances"
                        shift 1
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_instances"
                                ;;
                            run)
                                FUNCTION_CALL="ec2cli_run_instances"
                                ;;
                            attach | create)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -n | --vpcs)
                    #
                    # display details of vpcs for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_vpcs"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;

                -N | --network)
        			#
        			# display all network details for region
        			#
                    OPTION="$1"
                    shift 1
                    ;;

                -r | --region)
                    if parse_regioncode "$2"; then
                        REGION="$2"
                        shift 2
                    fi
                    ;;

                -t | --tags)
                    #
                    # Display details of all EC2 tags for region
                    # No region parameter, tags are global
                    OPTION="$1"
                    std_logger "[INFO]: OPTION global set to: ($OPTION)"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="ec2cli_help_command_list_tags"
                        shift 1
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_tags"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_tag"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -s | -snapshots | -snapshot | --snapshot | --snapshots)
                    #
                    # display details of EC2 snapshots for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="ec2cli_help_command_list_snapshots"
                        shift 1
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_snapshots"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_snapshot"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -v | --volumes)
                    #
                    # display details of EBS Volume Snapshots for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="ec2cli_help_command_list_volumes"
                        shift 1
                    else
                        case $COMMAND in
                            attach)
                                FUNCTION_CALL="ec2cli_attach_volume"
                                ;;
                            list)
                                FUNCTION_CALL="ec2cli_list_volumes"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                ??-*-[1-9])
                    #
                    # regioncode found, validate it
                    #
                    parse_regioncode $1
                    shift 1
                    ;;
                i-* | subnet-* | vpc-* | ami-* | sg-* | snap-* | vol-*)
                    RESOURCEID="$1"
                    shift 1
                    ;;
                -e | --export)
                    EXPORT="true"
                    shift 1
                    ;;
                -P | --spot)
                    std_logger "[INFO]: entering Spot Market Pricing Menu"
                    FUNCTION_CALL="SPOT_MARKET"
                    shift 1
                    ;;
                -S | --sort)
                    # sort column
                    if [ $2 ]; then
                        SORT_COL="$2"
                        shift 2
                    fi
                    ;;
                help)    # invoke detailed help menu
                    source $lib_path/help_menus.lib
                    case $COMMAND in
                        attach)
                            ec2cli_help_command_attach
                            exit 0
                            ;;
                        create)
                            ec2cli_help_command_create
                            exit 0
                            ;;
                        list)
                            ec2cli_help_command_list
                            exit 0
                            ;;
                        run)
                            ec2cli_help_command_run
                            exit 0
                            ;;
                    esac
                    ;;
                -V | --version)
                    echo -e "\n${bodytext}Package Info${bodytext}:" | indent04
                    std_message "${orange}ec2cli${bodytext}, version ${title}$VERSION${bodytext}" INFO | indent04
                    echo -e "\n${bodytext}Amazon command line interface (awscli)${bodytext}:\n" | indent04
                    environment_info "INFO" "awscli"
                    echo -e "\n${bodytext}Installed JSON Parser:${bodytext}" | indent04
                    environment_info "INFO" "jq"
                    echo -e "\n${bodytext}Operating System:${bodytext}" | indent04
                    environment_info "INFO" "os"
                    exit 0
                    ;;
                *)
                    std_error "Option [ $1 ] unknown. Invalid option specified. (code $E_BADARG)" $E_BADARG
                    exit $E_BADARG
                	;;
            esac
        done
        if [ ! $PROFILE ]; then
            PROFILE="$(profilename_prefix default)"
            std_logger "[INFO]: PROFILE default to: default"
        fi

        if [ ! $REGION ]; then
            # determine default region
            set_default_region $PROFILE
            REGION=$DEFAULT_REGION
        fi

        if [ $DBUGMODE ]; then
            std_logger "[INFO]: Debug Mode Enabled, debug set to $DBUGMODE"
        fi
    fi
    #
    # <-- end function ec2cli_parse_parameters -->
}


function profilename_prefix(){
    ##
    ##  Returns temporary credentials found for a role
    ##
    ##  Note:  temp credentials must be generated
    ##         prior to use; otherwise, this function
    ##         will return the profilename "as is"
    ##
    local profilename="$1"
    if [ "$(grep "gcreds-$profilename" ~/.aws/credentials)" ]; then
        PROFILE="gcreds-$profilename"
        echo "gcreds-$profilename"
    else
        PROFILE="$profilename"
        echo "$profilename"
    fi
    return 0
}


function xterm_reset(){
    ## resets default xterm colors (temporary) ##
    local set_colors="$1"
    #
    if [ $set_colors ]; then
        PS1_ORIGINAL="$PS1"
        export PS1="$PS1_ORIGINAL \$\[\${orange}\]"
    else
        # reset to orginal
        export PS1=$PS1_ORIGINAL
    fi
}


#
# START (MAIN) ----------------------------------------------------------------
#

# validate pre-run conditions
ec2cli_precheck

# reset default colors
#xterm_reset true

# temporily assign name
PROFILE="default"

# parse all cli parameters
parse_parameters $@

# execute
if [ $DBUGMODE ]; then
    echo -e "PROFILE: $PROFILE"
    echo -e "COMMAND: $COMMAND"
    echo -e "REGION: $REGION"
    echo -e "FUNCTION_CALL: $FUNCTION_CALL"
    if [ $RESOURCEID ]; then
        echo -e "RESOURCEID: $RESOURCEID"
    fi
fi


if [ "$FUNCTION_CALL" = "HELP" ]; then
    source $lib_path/help_menus.lib
    help_submenu $COMMAND
elif [ "$FUNCTION_CALL" = "ec2cli_help_command_list_instances" ]; then
    source $lib_path/help_menus.lib
    ec2cli_help_command_list_instances
elif [ "$FUNCTION_CALL" = "ec2cli_help_command_list_snapshots" ]; then
    source $lib_path/help_menus.lib
    ec2cli_help_command_list_snapshots
elif [ "$FUNCTION_CALL" = "ec2cli_help_command_list_tags" ]; then
    source $lib_path/help_menus.lib
    ec2cli_help_command_list_tags
elif [ "$FUNCTION_CALL" = "ec2cli_help_command_list_volumes" ]; then
    source $lib_path/help_menus.lib
    ec2cli_help_command_list_volumes
else
    # execute operations which require authentication to AWS
    PROFILE="$(profilename_prefix $PROFILE)"

    if authenticated $PROFILE; then
        # authenicated to aws successful
        if { [ "$OPTION" = "--tags" ] || [ "$OPTION" = "-t" ]; } && [ "$COMMAND" = "list" ]; then
            $FUNCTION_CALL $REGION $RESOURCEID

        elif { [ "$OPTION" = "--tags" ] || [ "$OPTION" = "-t" ]; } && [ "$COMMAND" = "create" ]; then
            $FUNCTION_CALL $REGION $RESOURCEID

        elif [ "$OPTION" = '-N' ] || [ "$OPTION" = '--network' ]; then
            ec2cli_list_vpcs $REGION
            ec2cli_list_subnets $REGION
            ec2cli_list_securitygroups $REGION

        elif [ "$FUNCTION_CALL" = "SPOT_MARKET" ]; then
            sh $lib_path/spot_prices.sh "$PROFILE"

        elif [ $EXPORT ]; then
            SORT_COL="false"
            $FUNCTION_CALL $REGION "$SORT_COL" $EXPORT
        else
            $FUNCTION_CALL $REGION $SORT_COL
        fi
    fi
fi

# reset terminal colors to original
#xterm_reset

# clean up
rm -fr $lib_path/__pycache__ || true

#
# END (MAIN) ------------------------------------------------------------------
#

exit 0
