#!/bin/bash
#_________________________________________________________________________
#                                                                         | 
#                                                                         |
#  Author:   Blake Huber                                                  |
#  Purpose:  Display details AWS ec2 resources from cli environment       |  
#  Name:     ec2cli                                                       |
#  Location: $EC2_REPO                                                    |
#  Requires: awscli, jq, dig, awk, sed                                    |
#  Environment Variables (required, global):                              |
#                                                                         |
#      SSH_KEYS            :   Dir containing ssh keys (.pem) files       |
#      AWS_ACCESS_KEY      :   IAM User Private Key                       |
#      AWS_SECRET_KEY      :   IAM User Public Key                        |
#      AWS_DEFAULT_REGION  :   Home AWS region                            |
#      EC2_REPO            :   Location of ec2cli utility                 |
#      REMOTE_RDP_PASSWD   :   Windows Login passwd (optional)            |
#                                                                         |
#  User:     $user                                                        |
#  Output:   CLI                                                          |
#  Error:    stderr                                                       |
#  Log:  $pkg_path/logs/                                                  |
#                                                                         |
#_________________________________________________________________________|

#	
# global variables
#
pkg=$(basename $0)
version="0.74"
pkg_path=$(cd $(dirname $0); pwd -P)
ec2cli_log="$pkg_path/logs/ec2cli.log"
host=$(hostname)
system=$(uname)

# error codes
E_DEPENDENCY=1                # exit code if missing required ec2cli dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter		
E_NETWORK_ACCESS=9            # exit code if no network access from current location
E_MISC=11                     # exit code if miscellaneous (unspecified) error

#
# Formatting
# 
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
reset=$(tput sgr0)
#   
BOLD=`tput bold`              
UNBOLD=`tput sgr0`           

# indent 
indent02() { sed 's/^/  /'; }
indent10() { sed 's/^/          /'; }
indent15() { sed 's/^/               /'; }
indent18() { sed 's/^/                  /'; }

#
# system functions  ------------------------------------------------------
#

function ec2cli-help(){
  cat <<EOM

 Help Contents

   ${white}${BOLD}Usage${UNBOLD}${reset} : ec2cli [OPTION] [COMMAND] [REGIONCODE] 

   ${white}${BOLD}Options${UNBOLD}${reset} :
     -a, --images       Amazon Machine Image (AMI) details for region
     -b, --subnets      Virtual Private Cloud (VPC) Subnet details
     -g, --sgroups      Security Group details for region
     -h, --help         Output this message
     -i, --instances    EC2 Instance details for region
     -n, --vpc          Virtual Private Cloud (VPC) Network details for region
     -N, --network      All network details for region
     -s, --snapshots    Snapshot details for region    
     -t, --tags         Tags details for EC2 sub services (all regions)
     -v, --volumes      Elastic Block Store (EBS) Volume details for region
  
   ${white}${BOLD}Commands${UNBOLD}${reset} (optional) : 
     list               List aws resource details [DEFAULT]
     attach             Attach/ Detach aws resource 
     create             Create new aws resource
     run                Run/ start existing aws resource

   ${white}${BOLD}Region Codes${UNBOLD}${reset} (optional) : 
     ap-northeast-1     Asia Pacific (Tokyo, Japan)       
     ap-northeast-2     Asia Pacific (Seoul, Korea)      
     ap-south-1         Asia Pacific (Mumbai, India)
     ap-southeast-1     Asia Pacific (Singapore)       
     ap-southeast-2     Asia Pacific (Sydney, Austrailia) 
     eu-central-1       Europe (Frankfurt, Germany)       
     eu-west-1          Europe (Ireland)          
     sa-east-1          South America (Sao Paulo, Brazil)
     us-east-1          United States (N. Virgina)   
     us-west-1          United States (N. California)    
     us-west-2          United States (Oregon)  

     If region code omitted, defaults to AWS default region 
    
   For additional help, see https://bitbucket.org/blakeca00/ec2cli/overview

EOM
}

function ec2cli-help-command-attach(){
    cat <<EOM

  COMMAND : ${BOLD}${white}attach${UNBOLD}${reset}

    The ${BOLD}${white}attach${UNBOLD}${reset} command can be used with the following options:
     -v, --volumes      Attach (Detach) EBS Volume to (from) an existing instance

EOM
}

function ec2cli-help-command-create(){
    cat <<EOM

  COMMAND : ${BOLD}${white}create${UNBOLD}${reset}

    The ${BOLD}${white}create${UNBOLD}${reset} command can be used with the following options:
     -a, --images       Create an Amazon Machine Image (AMI) from an EC2 instance
     -s, --snapshots    Create a snapshot from an EBS Volume
     -v, --volumes      Create an EBS Volume from a snapshot

EOM
}

function ec2cli-help-command-run(){
    cat <<EOM

  COMMAND : ${BOLD}${white}run${UNBOLD}${reset}

    The ${BOLD}${white}run${UNBOLD}${reset} command can be used with the following options:
     -i, --instances    Run/ Login to EC2 instances in specified region
     
EOM
}

function ec2cli-logger(){
    local msg="$1"
    if [[ ! $ec2cli_log ]]; then
        echo "$pkg: failure to call ec2cli-logger, $ec2cli_log location undefined"
        exit $E_NOLOG
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$ec2cli_log"
}

function ec2cli-message(){
    local msg="$1"
    ec2cli-logger "INFO: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n"
}

function ec2cli-error(){
    local msg="$1"
    ec2cli-logger "ERROR: $msg"
    echo -e "\n${yellow}[ ${red}ERRR$yellow ]$reset  $msg\n"
}

function ec2cli-error-exit(){
    local msg="$1"
    local status="$2"
    ec2cli-error "$msg"
    exit $status
}

function ec2cli-precheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash 
        ec2cli-error-exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi

    ## create log dir for ec2cli ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            echo "$pkg: failed to make log directory: $pkg_path/logs"
            exit $E_NOLOG
        fi
    fi

    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR     
    else
            TMPDIR="/tmp"
            cd $TMPDIR 
    fi
    
    ## check for required cli tools ##
    for prog in aws ssh dig; do
        if ! type "$prog" > /dev/null 2>&1; then
            ec2cli-error-exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    done
    
    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        ec2cli-error-exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi
    
    ## validate aws default region set (must occur post awscli config check) ##
    if [[ $(env | grep AWS_DEFAULT_REGION) ]]; then
	   REGION=$AWS_DEFAULT_REGION
    else
        # global env not set, check aws default region setting
        REGION=$(aws configure list | grep region | awk '{print $2}')
    fi
    
    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            ec2cli-error-exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi
    
    ## check global environment variables, linux instances ##
	if [[ ! $(env | grep SSH_KEYS) ]]; then
		#
		# path to ec2 .pem files not found, auto-login \
		# to instances will fail when attempted
		#
		ec2cli-error "SSH_KEYS environment variable not set. Login will fail when Command 'run' attempted." $E_DEPENDENCY
	fi
    #
    # <-- end function ec2cli-precheck -->
    #
}

function ec2cli-precheck-windows(){
	#
	# Windows RDP login deps (Linux client rdesktop)
	#
	# check global environment variables, windows instances
	if [[ ! $(env | grep REMOTE_RDP_PASSWD) ]]; then
		#
		# RDP password not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		ec2cli-error-exit "REMOTE_RDP_PASSWD global environment variable not set. Login to RDP EC2 instances will fail. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
	fi

    # check RDP for accessing windows instances from Linux
	if ! type rdesktop > /dev/null 2>1; then
		#
		# RDP app not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		ec2cli-error-exit "rdesktop app not found. Login to RDP EC2 instances will fail. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
	fi
    #
    # <-- end function ec2cli-precheck-windows -->
    #	
}

function ec2cli-convert-time(){
    # time format conversion (http://stackoverflow.com/users/1030675/choroba)
    num=$1
    min=0
    hour=0
    day=0
    if((num>59));then
        ((sec=num%60))
        ((num=num/60))
        if((num>59));then
            ((min=num%60))
            ((num=num/60))
            if((num>23));then
                ((hour=num%24))
                ((day=num/24))
            else
                ((hour=num))
            fi
        else
            ((min=num))
        fi
    else
        ((sec=num))
    fi
    echo "$day"d,"$hour"h,"$min"m  
    #
    # <-- end function ec2cli-convert-time -->
    #
}

function ec2cli-attach-volume(){
    # vars
    local CHOICE              # user selection
    local DEFAULTDEV          # default device
    local DEVICE
    local tmpVOLID
    local tmpINSTANCEID
    local INSTANCEID
    local REGION=$1
    local MAXCT               # array length
    local msg                 # msg string
    local VALID               # loop break
    local VOLID

    ## choose volume ##---------------------------------------------------
    echo -e "\n${BOLD}Volume choices: ${UNBOLD}$REGION\n" | indent18
    ec2cli-list-volumes $REGION > .text-output0.tmp
    grep "vol-" .text-output0.tmp > .text-output1.tmp 

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a VOLUMES < .text-output1.tmp

    # array max length
    MAXCT=${#VOLUMES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0  
    while (( i < $MAXCT )); do
            echo "($i): ""${VOLUMES[$i]}" >> .arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header display choices from array
    echo -e "\n     VolumeID      GB  State     Attached  InstanceId  VolType   Avail-Zone  Description"
    echo -e "     ------------  --  --------  --------  ----------  --------  ----------  ----------------------------"

    # values
    awk  '{ printf "%-4s %-13s %-3s %-9s %-9s %-11s %-9s %-11s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12}' .arrayoutput.tmp

    # Enter control structure to get user selection and validate
    VALID=0 # set loop break

    while [ $VALID -eq 0 ]; do
        # read volume choice in from user
        echo ""
        read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
        echo ""
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
            # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done

    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpVOLID=${VOLUMES[$CHOICE]}
    VOLID=$(echo $tmpVOLID | cut -c 1-12)
    echo "Volume "$VOLID" chosen."

    # clean up
    rm .text-output0.tmp .text-output1.tmp .arrayoutput.tmp

    ## choose instance ## ------------------------------------------------
    echo -e "\n${BOLD}EC2 Instance choices: ${UNBOLD}$REGION\n" | indent18
    ec2cli-list-instances $REGION > .text-output0.tmp
    grep "i-" .text-output0.tmp > .text-output1.tmp

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a INSTANCES < .text-output1.tmp

    # array max length
    MAXCT=${#INSTANCES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0
    while (( i < $MAXCT )); do
            echo "($i): ""${INSTANCES[$i]}" >> .arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header to display choices from array
    echo -e "\n     InstanceId    Type     State    SecurityGroup    Root-Volume     Version"
    echo -e "     ----------- ---------  -------  --------------   ------------   ---------" 

    # values
    awk  '{ printf "%-4s %-11s %-10s %-8s %-16s %-14s %-9s \n", \
        $1, $2, $3, $4, $5, $6, $7}' .arrayoutput.tmp

    # Enter control structure to get user selection and validate
    VALID=0 # loop break
    while [ $VALID -eq 0 ]; do
            # read volume choice in from user
            echo ""
            read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
            echo ""
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done

    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpINSTANCEID=${INSTANCES[$CHOICE]}
    INSTANCEID=$(echo $tmpINSTANCEID | cut -c 1-10)
    echo -e "Instance "$INSTANCEID" chosen.\n"

    # clean up
    rm .text-output0.tmp .text-output1.tmp .arrayoutput.tmp

    ## choose device ## --------------------------------------------------
    read -p  "${yellow}  Enter device to mount to [/dev/sda1]:  ${reset}" DEVICE
    DEFAULTDEV="/dev/sda1"

    if [ -z "$DEVICE" ]
    then
      DEVICE=$DEFAULTDEV
    else
      DEVICE=$DEVICE
    fi

    # execute
    echo -e "\nAttaching volume.....\n"
    aws ec2 attach-volume \
        --volume-id $VOLID \
        --instance-id $INSTANCEID \
        --device $DEVICE \
        --output table
    ## FIXME: capture error conditions if attach fails
    ## send to $msg

    # log and exit
    if [[ "cat $msg | grep error" ]]; then
        # errors while attaching
        ec2cli-error-exit "$msg" $E_MISC
    else
        ec2cli-message "Volume $VOLID attached to instance $INSTANCEID in region $REGION." INFO
    fi
    #
    # <-- end function ec2cli-attach-volume -->
    #   
}

function ec2cli-create-image(){
    # vars
    local REGION=$1         # aws region
    local CHOICE            # variable to hold user choice
    local DESCRIPTION       # user provided description for newly created image
    local INSTANCEID        # instance chosen for image creation
    local MAXCT             # max number of values in array
    local NOW               # date, formatted
    local NAME              # user provided name for newly created image
    local VALID             # loop break

    # pull json info, all instances in region
    aws ec2 describe-instances --region $REGION --output json > .jsonoutput.tmp

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' .jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}          # count instances found  

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        ec2cli-logger "INFO: function ec2cli-create-image: attempt to create AMI image"
        ec2cli-message "No EC2 instances found in region $REGION." INFO
        return
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' .jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' .jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' .jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' .jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' \
            .jsonoutput.tmp | cut -c 1-15) )
    # limit length of tag fields to 20 chars. NOTE: ARRAY ASSIGNMENT NOT WORKING CORRECTLY
    ARR_TAG=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' \
            .jsonoutput.tmp | cut -c 1-20) )

    # > 0 instances in region, print region identifier
    printf "\n${white}${BOLD}EC2 Instances${UNBOLD}${reset} : $REGION\n\n" | indent18

    # output table of json array
    i=0
    for id in ${ARR_ID[*]}; do
        echo "($i): "${ARR_ID[$i]} ${ARR_TYPE[$i]} ${ARR_STATE[$i]} ${ARR_SG[$i]} \
              ${ARR_DEV[$i]} ${ARR_TAG[$i]} >> .arrayoutput.tmp
        # incr ct     
        i=$(( $i+1 ))
    done

    # display choices from array
    echo -e "     InstanceID    Type     State    SecurityGroup    Root-Volume   Description"
    echo -e "     ----------  ---------  -------  ---------------  ------------  -------------------------"
    # values
    awk  '{ printf "%-4s %-11s %-10s %-8s %-16s %-13s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .arrayoutput.tmp 
    # footer
    printf "\nTotal Instances in region [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n" | indent10

    # get user input while checking type and range
    VALID=0    # set loop break
    while [ $VALID -eq 0 ]; do
            # read choice in from user
            echo ""
            read -p "${yellow}  Enter instance # to create Amazon Machine Image (AMI) [quit]: ${reset}" CHOICE 
            echo ""

            # assign instance to choice
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
                    ### FIXME:  Fails if enter integer with 2 digits ###
            else
                    if [[ -z "$CHOICE" ]]; then
                            # CHOICE is blank, clean up and assign default [quit]
                            rm .arrayoutput.tmp 
                            return
                            #exit $E_USER_CANCEL
                    else
                            # valid user entry, exit loop
                            VALID=1
                    fi
            fi
    done

    ## retrieve tag values Description, Name ##
    INSTANCEID=${ARR_ID[$CHOICE]}
    # retrieve json object for selected instance
    aws ec2 describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    NOW=$(date +"%Y-%m-%dT%H:%M:%S")    # date + 24 hr time
    TIME=$(date +"%H.%M.%S")            # 24 hr time stamp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' .jsoninstance.tmp) )
    
    # search thru array of tags assoc with this instances
    NAME=""             # initialize
    DESCRIPTION=""      # initialize
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name, map to description
        if [ $key == "Name" ] || [ $key == "name" ]; then
            DESCRIPTION="$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)""($INSTANCEID)"
        fi        
        # get description
        #if [ $key == "Description" ] || [ $key == "description" ]; then
        #    #DESCRIPTION=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
        #    DESCRIPTION="InstanceId_"$INSTANCEID  # STUB until issue 33 permanent fix    
        #fi
        # increment
        i=$(( $i+1 ))
    done

    ## defaults if no tags ##
    if [ "$NAME" == "" ]; then
        # no name tag exists, append unique 24 hr time stamp
        NAME="AMI."$TIME
    fi
    if [ "$DESCRIPTION" == "" ]; then 
        # no description tag exists
        DESCRIPTION="InstanceId_"$INSTANCEID
    fi

    # create image
    aws ec2 create-image \
        --region $REGION \
        --instance-id $INSTANCEID \
        --name "$NAME" \
        --description "$DESCRIPTION" \
        --output table

    # user msg, locate after ec2 create-image called in case of failure
    echo -e "\n** Amazon Machine Image creation start **\n" | indent02
    echo -e "${white}AMI Name :${reset} "$NAME | indent02
    echo -e "${white}AMI Description :${reset} "$DESCRIPTION | indent02
    echo ""
    # log 
    ec2cli-logger "INFO:  AMI image [$NAME] creation start"

    # clean up
    rm .jsonoutput.tmp .arrayoutput.tmp .jsoninstance.tmp
    #
    # <-- end function ec2cli-create-image -->
    #
}

function ec2cli-create-snapshot(){
    # vars
    local REGION=$1
    local NOW="$(date +"%Y-%m-%d")"
    local PROGRESSMSG="Snapshot creation started... "
    local VALID    # loop break
    
    VALID=0
    while [ $VALID -eq 0 ]; do
        #
        # choose volume ----------------------
        #
        # display volumes associated with default zone for user's AWS account
        ec2cli-list-volumes $REGION   # includes header

        # collect list of all current AWS Regions globally:
        aws ec2 describe-volumes \
                --region $REGION \
                --output text \
                --query 'Volumes[*].[VolumeId]' \
        >> .create-snapshot.tmp

        # check for non-zero ebs volumes in region
        if [[ ! "$(grep "vol-" .create-snapshot.tmp)" ]]; then
            # no ebs volumes to snapshot, exit
            rm .create-snapshot.tmp
            ec2cli-error-exit "No EBS volumes in region $REGION. Exiting." $E_DEPENDENCY
        fi

        # Use built-in IFS to read in all lines in tmp file
        IFS=$'\n' read -d '' -r -a VOLUMES < .create-snapshot.tmp

        # array max length
        MAXCT=${#VOLUMES[*]} # keep in mind, IFS starts array index at 0

        # load output choice array
        i=0  
        while (( i < $MAXCT )); do
                echo "($i): ""${VOLUMES[$i]}" >> .arrayoutput.tmp
                i=$(( $i+1 ))
        done

        # display choices from array
        echo -e "\nEnter the # of the volume of which you wish to take a snapshot."
        cat .arrayoutput.tmp
        # clean up
        rm .create-snapshot.tmp .arrayoutput.tmp

        # read volume choice in from user
        echo ""
        read -p "${yellow}  Enter # of choice or hit return quit [quit]: ${reset}" CHOICE
        echo ""

        # assign volume to choice
        if [ -z "$CHOICE" ]; then
                # CHOICE is blank, assign default
                CHOICE=0
                VALID=1
                return
        fi

        VOLID=${VOLUMES[$CHOICE]}
        ec2cli-message "Creating snapshot of $VOLID in region $REGION." INFO
        
        #
        # create snapshot ----------------------------------------------------
        #
        # description = concatenate volume date + Name tag
        NAMETAG=$(aws ec2 describe-volumes \
                --region $REGION \
                --volume-id  $VOLID \
                --query 'Volumes[*].[Tags[0].Value]' \
                --output text)

        DESCRIPTION=$NOW", ""$NAMETAG"

        # start snapshot
        aws ec2 create-snapshot \
                --output json \
                --region $REGION \
                --volume-id $VOLID \
                --description "$DESCRIPTION" | jq . 

        # progress meter while wait, inspect snapshot for VOLID
        aws ec2 wait snapshot-completed \
                --region $REGION \
                --filters Name="volume-id",Values=$VOLID &

        # call function to show on screen while wait
        ec2cli-spinner $PROGRESSMSG

        # log and exit
        ec2cli-message "Snapshot [$VOLID] created $NOW in region $REGION." INFO
        
        # create more snapshots
        echo ""
        read -p "${yellow}  Create another snapshot? [quit]: ${reset}" CHOICE
        echo ""
        if [ -z "$CHOICE" ]; then
                # CHOICE is blank, assign default (quit)
                VALID=1
                return
        fi
    # end while loop
    done
    #
    # <-- end function ec2cli-create-snapshot -->
    #
}

function ec2cli-create-tag(){
    local RESOURCEID
    local KEY
    local VALID
    local VALUE
    
    # resource
    echo -e "\n  Enter the resource ID to tag:"
    read -p "${yellow}  ResourceId: ${reset}" RESOURCEID
    echo ""
    case $RESOURCEID in
        *\ * )
            echo "Resource ID cannot contain spaces or special characters."
        ;;
    esac
    # tag components: 
    VALID=0    # set loop break
    while [[ $VALID -eq 0 ]]; do
        # get user input [KEY] while checking contents
        echo -e "\n  Enter the key name of the tag to create or update:"
        read -p "${yellow}  Key: ${reset}" KEY
        echo ""
        if [[ "$KEY" =~ \ |\' ]]; then 
            echo "Key cannot contain spaces or special characters."
        else
            # get user input [keyvalue]
            echo -e "\n  Enter the tag value:"
            read -p "${yellow}  Tag Value: ${reset}" VALUE
            echo ""
            VALID=1    # break
        fi
    done
    
    # TESTING STUB
    echo "Key: "$KEY
    echo "Value: "$VALUE
    
    aws ec2 create-tags \
        --resources $RESOURCEID \
        --tags Key="$KEY",Value="$VALUE"
    #
    # <-- end function ec2cli-cretae-tag -->
    #
}

function ec2cli-list-instances(){
    # vars
    local TOTAL             # region EC2 instance count
    local REGION=$1         # region identifier
    local NOW               # date, formatted
    local LAUNCHTIME        # date/time launched from json object
    local EPOCHLT           # LAUNCHTIME in epoch seconds
    local RUNSECS           # runtime in sec
    local MAXCT             # max length of array (json object)

    # pull json info, all instances in region
    aws ec2 describe-instances --region $REGION --output json > .jsonoutput.tmp

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' .jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}    # count instances found
    
    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        ec2cli-logger "INFO: function ec2cli-list-instances: list instances"
        ec2cli-message "No EC2 instances found in region $REGION." INFO
        return
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' .jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' .jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' .jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' .jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' .jsonoutput.tmp | cut -c 1-15) )
    # limit length of tag fields to 20 chars
    ARR_TAG=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' .jsonoutput.tmp | cut -c 1-20) ) 
    
    #
    # instances in region.  test if running instances
    #
    # print region identifier
    printf "\n${white}${BOLD}EC2 Instances${UNBOLD}${reset} : $REGION\n\n" | indent18

    if [ "$(printf '%s\n' "${ARR_STATE[@]}" | grep "running")" ]; then
        #
        # at least 1 running instance found, calc runtime
        i=0     # counter
        r=0     # running instance count

        while (( i < $MAXCT )); do
            if [ "${ARR_STATE[$i]}" == "running" ]; then
                # calc now in UTC epoch seconds
                NOW=$(date -u +%s)

                # calc launchtime
                LAUNCHTIME="${ARR_LT[$i]}"
                EPOCHLT=$(date -d"$LAUNCHTIME" +%s)
                RUNSECS=$(( $NOW-$EPOCHLT ))    # runtime (seconds)
                RT[$i]=$(ec2cli-convert-time $RUNSECS)
                # track # running instances
                r=$(( $r+1 ))
            else
                # if not running, blank runtime
                RT[$i]="-"
            fi
            # convert public IP format
            if [ "${ARR_IP[$i]}" == "null" ]; then
                # alter IP format
                ARR_IP[$i]="None"
            fi
            i=$(( $i+1 ))    # incr counter
        done

        # print header
        echo -ne "InstanceId Type State SecurityGroup Root-Volume Public-IP RunTime Tag\n \
            ----------  ---------  ------- --------------  ------------   \
            --------------  ----------   --------------------\n" > .body.tmp
        #
        # output table of json array
        #
        i=0
        while (( i < $MAXCT )); do
            echo "${ARR_ID[$i]}  ${ARR_TYPE[$i]}  ${ARR_STATE[$i]} ${ARR_SG[$i]}  \
                  ${ARR_DEV[$i]}  ${ARR_IP[$i]}  ${RT[$i]}  ${ARR_TAG[$i]}" >> .body.tmp
            i=$(( $i+1 ))
        done
        #
        # print and format output
        #
        awk  '{ printf "%-11s %-10s %-8s %-15s %-13s %-15s %-11s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9}' .body.tmp | indent02
        # print footer
        printf "\n\nTotal Instances [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}    ($r currently running)\n\n" | indent10
    else
        # no running instances, eliminate PublicIP and RunTime columns, print header
        echo -ne "InstanceId* Type State SecurityGroup Root-Volume Tag\n \
            ---------- --------- ------- -------------- ------------ \
            --------------------\n" > .body.tmp
        #
        # output table of json array
        #
        i=0
        while (( i < $MAXCT )); do
            echo "${ARR_ID[$i]} ${ARR_TYPE[$i]} ${ARR_STATE[$i]} ${ARR_SG[$i]} \
                  ${ARR_DEV[$i]} ${ARR_TAG[$i]}" >> .body.tmp
            # incr ct     
            i=$(( $i+1 ))
        done
            # print and format output
            awk  '{ printf "%-11s %-10s %-8s %-16s %-13s %-10s %-2s %-2s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .body.tmp | indent02

        # print footer
        printf "\nTotal Instances [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}    *No running instances.\n\n" | indent10

    fi

    # clean up
    rm .body.tmp .jsonoutput.tmp

    #
    # <-- end function ec2cli-list-instances -->
    #
}

function ec2cli-list-images(){
    # vars
    local i             # counter
    local REGION=$1     # region passed from global identifier
    local NUMLIST       # boolean parameter, 1 = output numbered list
    local MAXCT         # array length

    # print out numbered list of instances?
    if [[ $2 ]] && [[ $2 -eq 1 ]]; then NUMLIST=1; fi

    # retrieve json array
    aws ec2 describe-images --region $REGION --output json --owner self > .jsonimages.tmp
    ARR_IMAGEID=( $(jq -r ".Images[].ImageId" .jsonimages.tmp) )
    MAXCT=${#ARR_IMAGEID[*]}    # values in array

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        ec2cli-logger "INFO: function ec2cli-list-images: list AMI images"
        ec2cli-message "No Amazon Machine Images found in region $REGION." INFO
        rm .jsonimages.tmp    # clean up
        return
    fi

    # images exist in region, retrieve all other values 
    ARR_TYPE=( $(jq -r ".Images[].ImageType" .jsonimages.tmp) )
    ARR_VTYPE=( $(jq -r ".Images[].VirtualizationType" .jsonimages.tmp) )
    ARR_CREATEDATE=( $(jq -r ".Images[].CreationDate" .jsonimages.tmp) )
    ARR_SNAP=( $(jq -r ".Images[].BlockDeviceMappings[0].Ebs.SnapshotId" .jsonimages.tmp) )
    ARR_NAME=( $(jq -r ".Images[].Name" .jsonimages.tmp | cut -c 1-25) )    # limit to 25 chars
    ARR_DESCR=( $(jq -r ".Images[].Description" .jsonimages.tmp) )    

    # convert date-time format to %Y-%m-%d.T%H:%M
    i=0     # initialize counter
    for date in ${ARR_CREATEDATE[*]}; do
        ARR_CREATEDATE[$i]=$(date -d${ARR_CREATEDATE[$i]}  +%Y-%m-%d.T%H:%M)
        # echo "Formatted create date is: "${ARR_CREATEDATE[$i]}    # TESTING
        # increment counter
        i=$(( $i+1 ))
    done

    # print header
    echo -ne "AMI-id CreateDateTime Type vType SnapshotId Description\n \
            ------------ -----------------  ------- -----  ------------- \
            -------------------------\n" > .header.tmp

    # create table of json array
    i=0
    for image in ${ARR_IMAGEID[*]}}; do
        echo "${ARR_IMAGEID[$i]} ${ARR_CREATEDATE[$i]} ${ARR_TYPE[$i]} \
            ${ARR_VTYPE[$i]} ${ARR_SNAP[$i]}"" ${ARR_DESCR[$i]}" >> .body.tmp
        i=$(( $i+1 ))
    done
    # sort and combine results
    cat .header.tmp > .output.tmp
    cat .body.tmp | sort -k +2 >> .output.tmp

    ## print and format output ##
    # header, region identifier
    printf "\n${white}${BOLD}AMAZON MACHINE IMAGES (AMI) :${UNBOLD}${reset} $REGION\n\n" | indent18
    # format output
    awk  '{ printf "%-13s %-18s %-8s %-6s %-14s %-10s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .output.tmp | indent02
    # footer
    printf "\nTotal AMI Count [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n\n" | indent18

    # clean up
    rm .jsonimages.tmp .output.tmp .body.tmp
    #
    # <-- end function ec2cli-list-images -->
    #
}

function ec2cli-parse-instance-tag(){
    # vars
    local i             # counter
    local APP           # app tag key value
    local ENV           # env (environment) tag key value
    local INSTANCEID    # id of instance passed as $2
    local key           # key representing 1 tag
    local SEARCHKEY     # search instance tags to find this key
    local TAGVALUE      # value assoc with SEARCHKEY, if exists
    local REGION        # region identifier

    REGION=$1
    INSTANCEID=$2
    SEARCHKEY=$3
    ## retrieve tag values Description, Name ##
    # retrieve json object for selected instance
    aws ec2 describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' .jsoninstance.tmp) )
    
    # search thru array of tags assoc with this instances
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name 
        if [[ $key == "$SEARCHKEY" ]]; then
            TAGVALUE=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
            echo $TAGVALUE
            return
        fi        
        # increment
        i=$(( $i+1 ))
    done

    # clean up
    rm .jsoninstance.tmp
    #
    # <-- end function ec2cli-parse-instance-tag -->
    #
}

function ec2cli-rdp-login(){
	# vars
	local CHOICE                     # user selection variable
	local i                          # loop counter
	local IPADDRESS=$2               # public IP address of RDP windows instance
	local MAXCT                      # array size
    local USER                       # user entered userid
    local PASSWD                     # user entered passwd 
	local SIZE="90%"                 # RDP session win size relative to client resolution
	local RDP_USER="Administrator"   # default rdp user, Win instance login
	local TARGET=$1                  # target EC2 instance for starting/ log in
	local VALID                      # loop break

	# verify login prereqs
	ec2cli-precheck-windows

	# load array with choices
	RDP_SIZE[0]="90%"
	RDP_SIZE[1]="1366x768"
	RDP_SIZE[2]="1400x860"
	RDP_SIZE[3]="1900x1000"
	# size of array
	MAXCT=${#RDP_SIZE[*]}

	i=0    # counter
	while (( i < $MAXCT )); do
        	echo "($i): ""${RDP_SIZE[$i]}"  >> .type.tmp
        	i=$(( $i+1 ))
	done

	# print window size choices
	echo -e "\n\n${BOLD}Select an RDP Session Window Size:${UNBOLD}\n"
	awk -F "  " '{ printf "%-4s %-20s \n", $1, $2}' .type.tmp
	# get user input while checking type and range
	VALID=0    # set loop break
	while [[ $VALID -eq 0 ]]; do
        	# read instance choice in from user
	        echo ""
        	read -p "${yellow}  Enter # RDP window resolution or hit return for relative size [90%]: ${reset}" CHOICE
	        echo ""

        	if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
				# invalid user entry
                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
        	else
				# valid user entry, exit loop
                VALID=1
        	fi
	done
	if [ -z "$CHOICE" ]
	then
        	# CHOICE is blank, default chosen
	        CHOICE=0
	fi
    # assign size
	SIZE=${RDP_SIZE[$CHOICE]}

	# log
	ec2cli-message "Starting RDP Session with $SIZE RDP window size on instance ($TARGET)." INFO

    # password
    if [[ ! $(env | grep -i REMOTE_RDP_PASSWD) ]]; then
            echo ""
            read -p "${yellow}  Enter the RDP user required for login to this windows instance: ${reset}" RDP_USER
            echo ""
            read -p "${yellow}  Enter the $RDP_USER password to establish an RDP login to this windows instance: ${reset}" REMOTE_RDP_PASSWD
            echo ""
    fi

	# Start rdp desktop session
	rdesktop -u $RDP_USER -p $REMOTE_RDP_PASSWD -g $SIZE -a 24 $IPADDRESS & 
	
	### FIXME: Support multiple passwds. Solicit passwd from user or default to \
	### shell global env var (REMOTE_RDP_PASSWD) ###
    
    # clean up
    rm .type.tmp    
    # log and exit
    ec2cli-logger "INFO: RDP Instance ($TARGET) started. RDP session size: $SIZE."
    exit 0
    #
    # <-- end function ec2cli-rdp-login -->
    #
}

function ec2cli-run-instances(){
	# vars
	local ACCESS                # flag if ssh access from login location
    local IPADDRESS       		# public IP of instance
	local KEY             		# name of ssh key (.pem file) 
	local MAXCT           		# array length
	local MYCIDR           		# local IP of client running $pkg
	local NOW=$(date)     		# current time
	local OS              		# operating system of instance
	local PROGRESSTXT="EC2 Instance Starting Up.  Please wait... "
	local REGION=$1       		# target region
	local SSH_USER="ec2-user"   # default ssh user for login, Linux instance
	local TARGET                # instance to be started/ login
	local tmpID           		# temp holder for instance ID
	local VALID           		# loop break
    local i                     # loop counter
	
    #
	# choose instance -----------------
	#
	aws ec2 describe-instances \
	        --region $REGION \
	        --output text \
	        --query "Reservations[*].Instances[*]. \
	            [InstanceId, \
	            InstanceType, \
	            State.Name, \
	            SecurityGroups[0].GroupName, \
	            BlockDeviceMappings[0].Ebs.VolumeId, \
	            PublicIpAddress, \
	            Tags[0].Value]" \
	>> .text-output1.tmp

	# Use built-in IFS to read in all lines in tmp file
	IFS=$'\n' read -d '' -r -a INSTANCES < .text-output1.tmp

	# calc array max length | test for 0 instances
	MAXCT=${#INSTANCES[*]} # IFS starts array index at 0
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        ec2cli-logger "INFO: function ec2cli-run-instances: attempt to run instances"
        ec2cli-message "No EC2 instances found in region $REGION" INFO
        return
    fi

    # header
    echo -e "\n${white}${BOLD}Available Instances${UNBOLD}${reset}: $REGION\n" | indent18
	# load output choice array
	i=0
	while (( i < $MAXCT )); do
	        echo "($i): ""${INSTANCES[$i]}" >> .arrayoutput.tmp
	        i=$(( $i+1 ))
	done

	# display choices from array
	echo -e "     InstanceID    Type     State    SecurityGroup    Root-Volume     PublicIP      Description"
	echo -e "     ----------  ---------  -------  ---------------  ------------  --------------  -------------------------"

	# values
	awk  '{ printf "%-4s %-11s %-10s %-8s %-16s %-13s %-15s %-2s %-2s %-2s %-2s \n", \
	        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11}' .arrayoutput.tmp

	# get user input while checking type and range
	VALID=0    # set loop break

	while [ $VALID -eq 0 ]; do
	        # read choice in from user
	        echo ""
	        read -p "${yellow}  Enter instance # to start/ log in [quit]: ${reset}" CHOICE
	        echo ""

	        # assign instance to choice
	        if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
	                # invalid user entry
	                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
	                ### FIXME:  Fails if enter integer with 2 digits ###
	        else
	                if [[ -z "$CHOICE" ]]; then
	                        # CHOICE is blank, clean up and assign default [quit]
                            rm .arrayoutput.tmp .text-output1.tmp
	                        exit $E_USER_CANCEL
	                else
	                        # valid user entry, exit loop
	                        VALID=1
	                fi
	        fi
	done
    # msg instance to start/ login
	tmpID=${INSTANCES[$CHOICE]}
	TARGET=$(echo $tmpID | cut -c 1-10)
    # msg out
	ec2cli-message "Instance ($TARGET) selected." INFO

	#
	# network access check ------------
	#
	ec2cli-message "Verifying Network Access to ($TARGET). Please wait ..." INFO

	# retrieve secuirty group(s) of selected ec2 instance
	aws ec2 describe-instances \
	        --region $REGION \
	        --output text \
	        --instance-id $TARGET \
	        --query 'Reservations[].Instances[].SecurityGroups[*].GroupId' > .secgrp-ids.tmp 

	# discover local ip
	dig +short myip.opendns.com @resolver1.opendns.com > .myip.tmp
    MYCIDR="$(cat .myip.tmp)/32"

    # grab security group details
    aws ec2 describe-security-groups \
        --output json \
        --region $REGION \
        --group-ids $(cat .secgrp-ids.tmp) > .jsonoutput.tmp
    ARR_PORT=( $(jq -r '.SecurityGroups[].IpPermissions[].ToPort' .jsonoutput.tmp) )
    ARR_IP=( $(jq -r '.SecurityGroups[].IpPermissions[].IpRanges[].CidrIp' .jsonoutput.tmp) )
    MAXCT=${#ARR_PORT[*]} 

    i=0    # counter
    while (( i < $MAXCT )); do
        if [[ ${ARR_PORT[$i]} = 22 ]]; then
            if [[ ${ARR_IP[$i]} == "$MYCIDR" ]] || [[ ${ARR_IP[$i]} == "0.0.0.0/0" ]]; then
                ACCESS=1
                i=$MAXCT    # access found, break
            fi
        fi
        # incr counter
        i=$(( $i + 1 ))
    done

	if [[ $ACCESS = 1 ]]; then
	        # Access validated
			ec2cli-message "SSH access verified to instance ($TARGET). Proceeding..." INFO
	        # clean up
	        rm .myip.tmp .jsonoutput.tmp .secgrp-ids.tmp
	else
	        # No access from current login client location, clean up
	        rm .arrayoutput.tmp .text-output1.tmp .myip.tmp .jsonoutput.tmp .secgrp-ids.tmp
	        # log, exit
	        ec2cli-error-exit "No ssh access to instance ($TARGET). Please update security group settings. Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	#
	# start instance ------------------
	#
	# check to see if already started
    if [[ $(grep $TARGET .text-output1.tmp | grep running) ]]; then
        # instance already running, skip start
        ec2cli-message "Instance ($TARGET) already running.  Logging in..." INFO
    else
        # instance not running, attempt to start
	    aws ec2 start-instances --region $REGION --output json --instance-ids $TARGET | jq . 

	    # wait for instance to start, return after
	    aws ec2 wait instance-running --region $REGION --instance-ids $TARGET &

	    # call function to show on screen while wait
	    ec2cli-spinner

	    # FIXME (HACK) | login delay: loop for i seconds, display counter
    	i=10    # count in seconds
	    echo -e "\n "

	    while (( i > 0 )); do
	        printf "\rInstance available in: ""$i"" seconds"
	        sleep 1
	        i=$(( i-1 ))
	    done
    fi

	#
	# Log in --------------------------
	#
    ec2cli-message "Authenticating to instance ($TARGET)..." INFO
	# retrieve json object for selected instance
	aws ec2 describe-instances \
        --region $REGION \
        --output json \
		--instance-id $TARGET > .jsonoutput.tmp
	
	# discover public ip assignment
	IPADDRESS=$(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp)
	#
	# validate IP as public
	if [[ $IPADDRESS == "null" ]]; then
		ec2cli-error-exit "No public IP address found for ($TARGET). Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	# Check Windows or Linux
	OS=$(jq -r '.Reservations[].Instances[].Platform' .jsonoutput.tmp)

	if [[ $OS == "windows" ]]; then
			# windows instance, validate deps & log in via RDP
            # clean up
            rm .arrayoutput.tmp .text-output1.tmp .jsonoutput.tmp 
			# windows login
            ec2cli-rdp-login $TARGET $IPADDRESS
	else
		# Linux instance, discover required access key
		KEY=$(jq -r '.Reservations[].Instances[].KeyName' .jsonoutput.tmp)".pem"
		
		# update log and login
		ec2cli-logger "INFO: Linux Instance ($TARGET) started. "
		ssh -i $SSH_KEYS/$KEY $SSH_USER@$IPADDRESS

		# clean up and exit
		rm .arrayoutput.tmp .text-output1.tmp .jsonoutput.tmp 
    	exit 0
	fi
    #
    # <-- end function ec2cli-run-instances -->
    #	
}

function ec2cli-list-securitygroups(){
    # vars
    local REGION=$1
    local TOTAL

    # print region identifier
    printf "\n${white}${BOLD}SECURITY GROUPS${UNBOLD}${reset} : $REGION\n\n" | indent18

    # print header 
    echo -ne "GroupName Group-Id Ports Ports CidrIp VpcId Description\n \
            ---------------- ----------- ----- ----- ----------------- ------------ \
            ---------------------------\n" > .ec2-qv-securitygroups.tmp

    # output from aws
    aws ec2 describe-security-groups \
        --output text \
        --region $REGION \
        --query "SecurityGroups[*]. \
            [GroupName, \
            GroupId, \
            IpPermissions[0].FromPort, \
            IpPermissions[0].ToPort, \
            IpPermissions[0].IpRanges[0].CidrIp, \
            VpcId, \
            Tags[0].Value]" \
    >> .ec2-qv-securitygroups.tmp

    # count total
    TOTAL=$(cat .ec2-qv-securitygroups.tmp | grep "sg-" | wc -l)

    # print and format output
    awk  '{ printf "%-18s %-13s %-6s %-7s %-19s %-14s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7}' .ec2-qv-securitygroups.tmp | indent02

    # print footer
    printf "\n${white}${BOLD}$TOTAL${UNBOLD}${reset} Security Groups in region [$REGION]\n\n" | indent15

    # clean up
    rm .ec2-qv-securitygroups.tmp
    #
    # <-- end function ec2cli-list-securitygroups -->
    #
}

function ec2cli-list-snapshots(){
    # vars
    local REGION=$1
    local SUM
    local TOTAL

    # Sum size of all snapshots (footer)
    SUM=$(aws ec2 describe-snapshots --region $REGION --owner self | jq -r '.Snapshots | map(.VolumeSize) | add') 

    if [ $SUM == "null" ] || [ $SUM -eq 0 ]
    then
        # print footer if no snapshots found
        printf "\n** ${white}${BOLD}0${UNBOLD}${reset} snapshots in region [$REGION], total ${white}${BOLD}0${UNBOLD}${reset} GB (est) **\n\n" | indent10
    else
        # snapshots found, print region identifier
        printf "\n${white}${BOLD}SNAPSHOTS${UNBOLD}${reset} : $REGION\n\n" | indent18

        # print header 
        echo -ne "SnapId Vo1. State Prog VolumeId Description\n \
                ------------- ----  --------- ---- ------------ \
                ----------------------------------------\n" > .ec2-qv-snapshots.tmp
        
        # output from aws
        aws ec2 describe-snapshots \
            --owner self \
            --output text \
            --region $REGION \
            --query "Snapshots[*]. \
                [SnapshotId, \
                VolumeSize, \
                State, \
                Progress,\
                VolumeId,\
                Description]" | \
        sort -k +6  >> .ec2-qv-snapshots.tmp

        # count total
        TOTAL=$(cat .ec2-qv-snapshots.tmp | grep "snap-" | wc -l)

        # print and format output
        awk  '{ printf "%-14s %-5s %-10s %-5s %-13s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9}' .ec2-qv-snapshots.tmp | indent02

        # print footer
        printf "\n${white}${BOLD}$TOTAL${UNBOLD}${reset} snapshots in region [$REGION], total ${white}${BOLD}$SUM${UNBOLD}${reset} GB (est)\n\n" | indent10

        # clean up
        rm .ec2-qv-snapshots.tmp
    fi
    #
    # <-- end function ec2cli-list-snapshots -->
    #
}

function ec2cli-spinner(){
    # vars
    local PROGRESSTXT="Please wait..."
    # visual progress marker function
    # http://stackoverflow.com/users/2869509/wizurd
    # vars
    local pid=$!
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf "\r$PROGRESSTXT[%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    #
    # <-- end function ec2cli-spinner -->
    #
}


function ec2cli-list-subnets(){
    # vars
    local TOTAL
    local REGION=$1

    # print region identifier
    printf "\n${white}${BOLD}SUBNETS${UNBOLD}${reset} : $REGION\n\n" | indent18
    # print header 
    echo -ne "Name SubnetId Public CIDR-Block #IPs AvailZone Default\n \
    ------------- --------------- ------ --------------- ---- ---------- -------\n" > .ec2-qv.tmp
    # output from aws
    aws ec2 describe-subnets \
        --output text \
        --region $REGION \
        --query "Subnets[*]. \
            [Tags[0].Value, \
            SubnetId, \
            MapPublicIpOnLaunch, \
            CidrBlock, \
            AvailableIpAddressCount, \
            AvailabilityZone, \
            DefaultForAz]" | sort -k +4n >> .ec2-qv.tmp
    # count total
    TOTAL=$(cat .ec2-qv.tmp | grep "subnet-" | wc -l)
    # print and format output
    awk  '{ printf "%-15s %-17s %-7s %-16s %-6s %-12s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7}' .ec2-qv.tmp | indent02
    # print footer
    printf "\nTotal Subnets, [$REGION]: ${white}${BOLD}$TOTAL${UNBOLD}${reset}\n\n" | indent15
    # clean up
    rm .ec2-qv.tmp
    #
    # <-- end function ec2cli-list-subnets -->
    #
}

function ec2cli-list-tags(){
    # vars
    local RESOURCEID

    if [[ $# -eq 0 ]]; then
        echo " "
        aws ec2 describe-tags --output table
        echo " "
    else
        # resource ID given by user
        RESOURCEID=$1
        tags=""
        tags=$(aws ec2 describe-tags \
                --filters="Name=resource-id,Values=$RESOURCEID" \
                --output json | grep $RESOURCEID)
        if [[ $tags = "" ]]; then
            # no tags exist for resource
            ec2cli-message "No tags found for resource [$RESOURCEID]." INFO
        else
            aws ec2 describe-tags \
                --filters="Name=resource-id,Values=$RESOURCEID" \
                --output table
        fi
    fi
    #
    # <-- end function ec2cli-list-tags -->
    #
}

function ec2cli-list-volumes(){
    # vars
    local REGION=$1
    local SUM
    local TOTAL

    # sum total size of all volumes (display in footer)
    SUM=$(aws ec2 describe-volumes \
        --region $REGION \
        --output json | jq -r '.Volumes | map(.Size) | add')

    if [ $SUM == "null" ] || [ $SUM -eq 0 ]
    then
        # print footer if no volumes found
        printf "\n** ${white}${BOLD}0${UNBOLD}${reset} volumes in region [$REGION], total ${white}${BOLD}0${UNBOLD}${reset} GB **\n\n" | indent10
    else
        #
        # volumes found, print region identifier
        #
        printf "\n${white}${BOLD}EBS VOLUMES${UNBOLD}${reset} : $REGION\n\n" | indent18
        # print header 
        echo -ne "Volume-Id GB State Attached InstanceId VolType Avail-Zone Description\n \
                ------------ -- -------- -------- ---------- -------- ---------- \
                -----------------------------\n" > .ec2-qv-volumes.tmp
        # output from aws
        aws ec2 describe-volumes \
            --output text \
            --region $REGION \
            --query "Volumes[*]. \
                [VolumeId, \
                Size, \
                State, \
                Attachments[0].State,
                Attachments[0].InstanceId, \
                VolumeType, \
                AvailabilityZone, \
                Tags[0].Value]" \
        >> .ec2-qv-volumes.tmp
        # count total
        TOTAL=$(cat .ec2-qv-volumes.tmp | grep "vol-" | wc -l)
        # print and format output
        awk  '{ printf "%-13s %-3s %-9s %-9s %-11s %-9s %-11s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .ec2-qv-volumes.tmp | indent02
        # print footer
        printf "\n${white}${BOLD}$TOTAL${UNBOLD}${reset} volumes in region [$REGION], total "${white}${BOLD}$SUM${UNBOLD}${reset}" GB\n\n" | indent10
        # clean up
        rm .ec2-qv-volumes.tmp
    fi
    #
    # <-- end function ec2cli-list-volumes -->
    #
}

function ec2cli-list-vpcs(){
    # vars
    local TOTAL

    # print region identifier
    printf "\n${white}${BOLD}Virtual Private Clouds (VPC)${UNBOLD}${reset} : $REGION\n\n" | indent18
    # print header 
    echo -ne "VpcId State Tenancy CIDR-Block Default\n \
            ------------ --------- ------- ------------------ -------\n" > .ec2-qv-vpc.tmp
    # output from aws
    aws ec2 describe-vpcs \
        --output text \
        --region $REGION \
        --query "Vpcs[*]. \
            [VpcId, \
            State, \
            InstanceTenancy, \
            CidrBlock, \
            IsDefault]" | sort -k +4n \
    >> .ec2-qv-vpc.tmp 
    # count total
    TOTAL=$(cat .ec2-qv-vpc.tmp | grep "vpc-" | wc -l)

    # print and format output
    # Note: Since awk is looking for blank space as delimiter, we allow spaces
    #       in the description field by telling awk these are 2 char columns.
    #
    awk  '{ printf "%-14s %-10s %-9s %-20s %-9s \n", \
            $1, $2, $3, $4, $5}' .ec2-qv-vpc.tmp | indent02
    # print footer
    printf "\nTotal VPCs, $REGION: ${white}${BOLD}$TOTAL${UNBOLD}${reset}\n\n" | indent18
    # clean up
    rm .ec2-qv-vpc.tmp
    #
    # <-- end function ec2cli-list-vpcs -->
    #
}

function parse-regioncode(){
	#
    # retrieve codes for all valid AWS Regions globally:
    #
    aws ec2 describe-regions --output text --query 'Regions[*].[RegionName]' > .rawoutput.tmp

    if [ "$1" == "$(grep $1 .rawoutput.tmp 2>/dev/null)" ]; then
        # aws region given
        REGION=$1
    else
        # bad regioncode, clean up and exit
        rm .rawoutput.tmp
        ec2cli-error-exit "Invalid AWS region code [ $1 ]. See ec2cli --help. Exiting (code $E_BADARG)" $E_BADARG
    fi
    # clean up
    rm .rawoutput.tmp   
    #
    # <-- end function parse-regioncode -->
    #
}

function parse-command(){
    COMMAND=$1
    # check if command is a region code
    if [[ $COMMAND = ??-*-[1-9] ]]; then
        # region code given instead 
        # user requests default (list)
        parse-regioncode $COMMAND
        COMMAND="list"    # set to default, no command given
        return
    elif [[ $COMMAND = i-* ]] || [[ $COMMAND = subnet-* ]] || [[ $COMMAND = vpc-* ]] \
        || [[ $COMMAND = ami-* ]] || [[ $COMMAND = sg-* ]] || [[ $COMMAND = snap-* ]]  \
        || [[ $COMMAND = vol-* ]]; then
        # resource id given instead of a command
        RESOURCEID=$COMMAND
        COMMAND="list"    # set to default, resource-id given instead of command
        return
    fi
    case $COMMAND in 
        attach | Attach | ATTACH | attch | atach)
            COMMAND="attach"
            ;;
        list | List | LIST | lis | li | l)
            COMMAND="list"
            ;;
        create | Create | CREATE | creat | cre | cr )
            COMMAND="create"
            ;;
        run | Run | RUN | ru | r | start | Start)
            COMMAND="run"
            ;;
        *)
            ec2cli-error "Command [ $COMMAND ] unknown. Invalid option specified. (code $E_BADARG)" $E_BADARG
            ec2cli-help
            exit $E_BADARG
            ;;
    esac
    #
    # <-- end function parse-command -->
    #
}

#
# START (MAIN) ----------------------------------------------------------------
#

# validate pre-run conditions
ec2cli-precheck

# validate region code
if [[ $3 ]]; then
    parse-regioncode $3
fi 
if [[ $2 ]]; then
    parse-command $2
else
    COMMAND="list"    # if command not given, set to default 
fi
if [[ $1 ]]; then
    OPTION=$1   
    case $COMMAND in
        attach | Attach | ATTACH | attac)    
            # parse options
            case $OPTION in 
                -v | --volumes)
                    #
                    # attach EBS Volume to instance in specified region
                    #
                    ec2cli-message "Attach functionality under development" STUB
                    #ec2cli-attach-volume $REGION
                    ;;
                *)
                    ec2cli-message "Option [ $1 ] not supported for $COMMAND command." INFO
                    ec2cli-help-command-attach
                    ;;
            esac
            ;;

        create | Create | CREATE | creat)
            # parse options
            case $OPTION in           
                -a | -ami | -amis | --amis | -images | --images)
                    #
                    # display details of Amazon Machine Images for region [STUB]
                    #
                    #ec2cli-message "functionality currently under development" STUB
                    ec2cli-create-image $REGION
                    ;;
                -h | --h | -help | --help)
                    #
                    # display help contents
                    #
                    ec2cli-help
                    ;;
                -s | -snapshots | -snapshot | --snapshot | --snapshots)
                    #
                    # display details of EC2 snapshots for region
                    #
                    ec2cli-create-snapshot $REGION
                    ;;
                -v | --volumes)
                    #
                    # create EBS Volume in specified region
                    #
                    ec2cli-message "create volume functionality under development" STUB
                    #ec2cli-create-volume $REGION
                    ;;
                *)
                    ec2cli-message "Option [ $1 ] not supported for $COMMAND command." INFO
                    ec2cli-help-command-create
                    ;;
            esac
            ;;

        list | List | LIST | lis)
            # parse options
            case $OPTION in           
                -a | -ami | -amis | --amis | -images | --images)
                    #
                    # display details of Amazon Machine Images for region
                    #
                    ec2cli-list-images $REGION
                	;;
                -b | -subnets | --subnet | --subnets)
                    #
                    # display details of all regional vpc subnets
                    #
                    ec2cli-list-subnets $REGION
                	;;
                -g | --sgroups | --securitygroups)
                    #
                    # display details of EC2 security groups for region
                    #
                    ec2cli-list-securitygroups $REGION
                	;;
                -h | --h | -help | --help)
                    #
                    # display help contents
                    #
                    ec2cli-help
                	;;
                -i | --instances)
                    #
                    # display instances details for region
                    #
                    ec2cli-list-instances $REGION
                	;;
                -n | --vpcs)
                    #
                    # display details of vpcs for region
                    #
                    ec2cli-list-vpcs $REGION
                	;;
                -N | --network | --networks | --Network | --Networks)
        			#
        			# display all network details for region
        			#
        			ec2cli-list-vpcs $REGION
        			ec2cli-list-subnets $REGION
        			ec2cli-list-securitygroups $REGION
        			;;
                -t | --tags)
                    #
                    # Display details of all EC2 tags for region
                    # No region parameter, tags are global 
                    ec2cli-list-tags $RESOURCEID    
                	;;
                -s | -snapshots | -snapshot | --snapshot | --snapshots)
                    #
                    # display details of EC2 snapshots for region
                    #
                    ec2cli-list-snapshots $REGION
                	;;
                -v | --volumes)
                    #
                    # display details of EBS Volume Snapshots for region
                    #
                    ec2cli-list-volumes $REGION
                	;;
                *)
                    ec2cli-error "Option [ $1 ] unknown. Invalid option specified. (code $E_BADARG)" $E_BADARG
                    ec2cli-help
                    exit $E_BADARG
                	;;
            esac
            ;;

        run | Run | RUN | start | Start)
            # parse options
            case $OPTION in           
                -a | -ami | -amis | --amis | -images | --images)
                    #
                    # Create instance from Amazon Machine Image in region [STUB]
                    #
                    ec2cli-message "run image functionality under development" STUB
                    #ec2cli-create-instance $REGION
                    ;;
                -h | --h | -help | --help)
                    #
                    # display help contents
                    #
                    ec2cli-help
                    ;;
                -i | --instances)
                    #
                    # start instance / login if already running
                    #
                    ec2cli-run-instances $REGION
                    ;;
                -s | -snapshots | -snapshot | --snapshot | --snapshots)
                    #
                    # Create a volume from EC2 snapshots in specified region [STUB]
                    #
                    ec2cli-message "create volume from snapshot functionality under development" STUB
                    #ec2cli-create-volume $REGION
                    ;;
                *)
                    ec2cli-message "Option [ $1 ] not supported for $COMMAND command." INFO
                    ec2cli-help-command-run
                    ;;
            esac
            ;;
    esac
else
    # no options specified, display help (-h, --help)
    ec2cli-help
fi

#
# END (MAIN) ------------------------------------------------------------------
#

exit 0
