#!/bin/bash
#_________________________________________________________________________
#                                                                         |
#                                                                         |
#  Author:   Blake Huber                                                  |
#  Purpose:  Display details AWS ec2 resources from cli environment       |
#  Name:     ec2cli                                                       |
#  Location: $EC2_REPO                                                    |
#  Requires: awscli, jq, dig, awk, sed                                    |
#  Environment Variables (required, global):                              |
#                                                                         |
#      SSH_KEYS            :   Dir containing ssh keys (.pem) files       |
#      AWS_ACCESS_KEY      :   IAM User Private Key                       |
#      AWS_SECRET_KEY      :   IAM User Public Key                        |
#      AWS_DEFAULT_REGION  :   Home AWS region                            |
#      EC2_REPO            :   Location of ec2cli utility                 |
#      REMOTE_RDP_PASSWD   :   Windows Login passwd (optional)            |
#                                                                         |
#  User:     $user                                                        |
#  Output:   CLI                                                          |
#  Error:    stderr                                                       |
#  Log:  $pkg_path/logs/                                                  |
#                                                                         |
#_________________________________________________________________________|

#
# global variables
#
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
ec2cli_log="$pkg_path/logs/ec2cli.log"
host=$(hostname)
system=$(uname)

# source lib deps
source $pkg_path/lib/version.lib        # package VERSION global var

# error codes
E_DEPENDENCY=1                # exit code if missing required ec2cli dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTH=4                      # exit code if authentication fails to aws
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter
E_NETWORK_ACCESS=9            # exit code if no network access from current location
E_MISC=11                     # exit code if miscellaneous (unspecified) error

# Configuration files, ancillary vars
CONFIG_DIR="ec2cli"
CONFIG_ROOT="$HOME/.config"
CONFIG_PATH="$CONFIG_ROOT/$CONFIG_DIR"
CONFIG_PATH_ALT="$HOME/.ec2cli"
REGION_CONFIGFILE="regions.list"
REFRESH_REGIONCODES="14"      # days
FLOAT_DECIMAL="1"             # number of floating point decimal places to output

#
# Formatting
#
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
orange='\033[38;5;95;38;5;214m'
brightgreen='\033[38;5;95;38;5;46m'
gray=$(tput setaf 008)
lgray='\033[38;5;95;38;5;251m'    # light gray
dgray='\033[38;5;95;38;5;8m'      # dark gray

# bright colors
brightblue='\033[38;5;51m'
brightcyan='\033[0;36m'
#brightgreen='\033[38;5;46m'
brightyellow='\033[38;5;11m'
brightyellow2='\033[38;5;95;38;5;226m'
brightwhite='\033[38;5;15m'
bluepurple='\033[38;5;68m'

# ansi formatting
bold='\u001b[1m'
underline='\u001b[4m'

# reset colors -- all
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

# Initialize ansi colors
title=$(echo -e ${bold}${white})
options=$(echo -e ${white})
resources=${yellow}
commands=$(echo -e ${brightcyan})   # use for ansi escape color codes
regions=$(echo -e ${bluepurple})
url=$(echo -e ${underline}${brightblue})
frame=$(echo -e ${brightgreen})
#body=$(echo -e ${reset}${lgray})            # report body text; set to reset for native xterm
body=$(echo -e ${reset})            # report body text; set to reset for native xterm
ast="$(echo -e ${brightyellow})"    # astrick
backcolor=$(echo -e ${brightgreen})
backcolor=${reset}

#
# system functions  ------------------------------------------------------
#


# indent
function indent02() { sed 's/^/  /'; }
function indent04() { sed 's/^/    /'; }
function indent10() { sed 's/^/          /'; }
function indent15() { sed 's/^/               /'; }
function indent18() { sed 's/^/                  /'; }
function indent25() { sed 's/^/                         /'; }

function ec2cli_help(){
  cat <<EOM


  Help Contents
  -------------

      ${white}${BOLD}SYNOPSIS${UNBOLD}${reset}:

              $ ec2cli  [${options}OPTION${reset}]  ${resources}RESOURCE${reset}${backcolor}  [${cyan}COMMAND${reset}${backcolor}]  [${regions}REGIONCODE${reset}${backcolor}]

                    [-p | --profile <PROFILENAME> ]
                    [-V | --version ]
                    [-d | ---debug  ]
                    [-h | --help    ]

      ${white}${BOLD}OPTIONS${UNBOLD}${backcolor}:
          ${options}-p${backcolor},${options} --profile${backcolor} (str) Profile name of an IAM user from the local awscli
                              config for which you want to rotate access keys
          ${options}-V${backcolor},${options} --version${backcolor}:      Print package version, dependency versions
          ${options}-d${backcolor},${options} --debug${backcolor}:        Enable verbose log output, enhance stdout messaging
          ${options}-h${backcolor},${options} --help${backcolor}:         Display help

      ${white}${BOLD}RESOURCES${UNBOLD}${backcolor}:
          ${resources}-a${backcolor},${resources} --images       ${backcolor}Amazon Machine Image (AMI) details (regional)
          ${resources}-b${backcolor},${resources} --subnets      ${backcolor}Virtual Private Cloud (VPC) Subnet details (regional)
          ${resources}-g${backcolor},${resources} --sgroups      ${backcolor}Security Group details (regional)
          ${resources}-i${backcolor},${resources} --instances    ${backcolor}EC2 Instance details (regional)
          ${resources}-n${backcolor},${resources} --vpc          ${backcolor}Virtual Private Cloud (VPC) Network details (regional)
          ${resources}-N${backcolor},${resources} --network      ${backcolor}All network details (regional)
          ${resources}-s${backcolor},${resources} --snapshots    ${backcolor}Snapshot details (regional)
          ${resources}-P${backcolor},${resources} --spot         ${backcolor}Spot Market Pricing (all regions)
          ${resources}-t${backcolor},${resources} --tags         ${backcolor}Tags details for EC2 sub services (all regions)
          ${resources}-v${backcolor},${resources} --volumes      ${backcolor}Elastic Block Store (EBS) Volume details (regional)

      ${white}${BOLD}COMMANDS${UNBOLD}${backcolor}:
          ${cyan}list               ${backcolor}List aws resource details [DEFAULT]
          ${cyan}attach             ${backcolor}Attach/ Detach aws resource
          ${cyan}create             ${backcolor}Create new aws resource
          ${cyan}run                ${backcolor}Run/ start existing aws resource

      ${white}${BOLD}REGIONCODES${UNBOLD}${backcolor}:
          ${regions}ap-northeast-1     ${backcolor}Asia Pacific (Tokyo, Japan)
          ${regions}ap-northeast-2     ${backcolor}Asia Pacific (Seoul, Korea)
          ${regions}ap-south-1         ${backcolor}Asia Pacific (Mumbai, India)
          ${regions}ap-southeast-1     ${backcolor}Asia Pacific (Singapore)
          ${regions}ap-southeast-2     ${backcolor}Asia Pacific (Sydney, Austrailia)
          ${regions}ca-central-1       ${backcolor}Canada (Montreal, CA)
          ${regions}eu-central-1       ${backcolor}Europe (Frankfurt, Germany)
          ${regions}eu-west-1          ${backcolor}Europe (Ireland)
          ${regions}eu-west-2          ${backcolor}Europe (London, UK)
          ${regions}eu-west-3          ${backcolor}Europe (Paris, France)
          ${regions}sa-east-1          ${backcolor}South America (Sao Paulo, Brazil)
          ${regions}us-east-1          ${backcolor}United States (N. Virgina)
          ${regions}us-east-2          ${backcolor}United States (Ohio)
          ${regions}us-west-1          ${backcolor}United States (N. California)
          ${regions}us-west-2          ${backcolor}United States (Oregon)

          If region code omitted, defaults to AWS default region

        For additional help, see ${url}https://bitbucket.org/blakeca00/ec2cli/overview${reset}


EOM
    exit 0
}

function std_logger(){
    local msg="$1"
    local prefix="$2"
    #
    if [ ! $prefix ]; then
        prefix="[INFO]"
    fi
    if [[ ! $ec2cli_log ]]; then
        echo "$prefix: $pkg ($VERSION): failure to call std_logger, $ec2cli_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg (v$VERSION): $msg" >> "$ec2cli_log"
}

function std_message(){
    local msg="$1"
    local format="$3"
    #
    std_logger "$msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:5}"
        shift
    fi
    if [ $format ]; then
        echo -e "${yellow}[ $cyan$pref$yellow ]$reset  $msg" | indent04
    else
        echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent04
    fi
}

function std_error(){
    local msg="$1"
    std_logger "[ERROR]: $msg"
    echo -e "\n${yellow}[ ${red}ERROR${yellow} ]$reset  $msg\n" | indent04
}

function std_warn(){
    local msg="$1"
    std_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent04
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent04
    fi
}

function std_error_exit(){
    local msg="$1"
    local status="$2"
    std_error "$msg"
    exit $status
}

function environment_info(){
    local msg_header=$1
    local dep=$2
    local version_info
    local awscli_ver
    local boto_ver
    local python_ver
    #
    version_info=$(aws --version 2>&1)
    awscli_ver=$(echo $version_info | awk '{print $1}')
    boto_ver=$(echo $version_info | awk '{print $4}')
    python_ver=$(echo $version_info | awk '{print $2}')
    #
    if [[ $dep == "aws" ]]; then
        std_logger "[$msg_header]: awscli version detected: $awscli_ver"
        std_logger "[$msg_header]: Python runtime detected: $python_ver"
        std_logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        std_logger "[$msg_header]: boto library detected: $boto_ver"

    elif [[ $dep == "awscli" ]]; then
        std_message "awscli version detected: ${accent}${BOLD}$awscli_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04
        std_message "boto library detected: ${accent}${BOLD}$boto_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04
        std_message "Python runtime detected: ${accent}${BOLD}$python_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04

    elif [[ $dep == "os" ]]; then
        std_message "Kernel detected: ${title}$(echo $version_info | awk '{print $3}')${reset}" $msg_header | indent04

    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        std_message "JSON parser detected: ${title}$(echo $version_info)${reset}" $msg_header | indent04

    else
        std_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function environment_info -->
}

function authenticated(){
    ## validates authentication using iam user or role ##
    local profilename="$1"
    local response
    #
    response=$(aws sts get-caller-identity --profile $profilename 2>&1)
    if [ "$(echo $response | grep Invalid)" ]; then
        std_message "The IAM profile provided ($profilename) failed to authenticate to AWS. Exit (Code $E_AUTH)" "AUTH"
        return 1
    elif [ "$(echo $response | grep found)" ]; then
        std_message "The IAM user or role ($profilename) cannot be found in your local awscli config. Exit (Code $E_BADARG)" "AUTH"
        return 1
    elif [ "$(echo $response | grep Expired)" ]; then
        std_message "The sts temporary credentials for the role provided ($profilename) have expired. Exit (Code $E_AUTH)" "INFO"
        return 1
    else
        return 0
    fi
}

function ec2cli_precheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        std_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi

    ## create log dir for ec2cli ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            echo "$pkg: failed to make log directory: $pkg_path/logs"
            exit $E_NOLOG
        fi
    fi

    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR
    else
        std_logger "[INFO]: Failed to find tempfs ram disk.  Using /tmp as alternate"
        TMPDIR="/tmp"
        cd $TMPDIR
    fi

    ## check for required cli tools ##
    for prog in aws ssh dig awk sed bc; do
        if ! type "$prog" > /dev/null 2>&1; then
            std_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $DBUGMODE ]; then
            environment_info "DBUG" $prog
        fi
    done

    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        std_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi

    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            std_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## check global environment variables, linux instances ##
	if [[ ! $(env | grep SSH_KEYS) ]]; then
		#
		# path to ec2 .pem files not found, auto-login \
		# to instances will fail when attempted
		#
		std_error "SSH_KEYS environment variable not set. Login will fail when Command 'run' attempted." $E_DEPENDENCY
	fi

    ## config directories, files ##
    if [ -d $CONFIG_ROOT ]; then
        if [ ! -d $CONFIG_PATH ]; then
            std_logger "[INFO]: Directory CONFIG_PATH ($CONFIG_PATH) not found, creating."
            mkdir $CONFIG_PATH
        fi
    else
        std_logger "[INFO]: Directory CONFIG_ROOT ($CONFIG_ROOT) not found, use alternate."
        if [ ! -d $CONFIG_PATH_ALT ]; then
            std_logger "[INFO]: Directory CONFIG_PATH_ALT ($CONFIG_PATH_ALT) not found, creating."
            mkdir $CONFIG_PATH_ALT
        fi
        CONFIG_PATH=$CONFIG_PATH_ALT
    fi

    # check regioncode setup
    setup_regioncodes
    #
    # <-- end function ec2cli_precheck -->
    #
}

function ec2cli_precheck-windows(){
	#
	# Windows RDP login deps (Linux client rdesktop)
	#
	# check global environment variables, windows instances
	if [[ ! $(env | grep REMOTE_RDP_PASSWD) ]]; then
		#
		# RDP password not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		std_error_exit "REMOTE_RDP_PASSWD global environment variable not set. Login to RDP EC2 instances will fail. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
	fi

    # check RDP for accessing windows instances from Linux
	if ! type rdesktop > /dev/null 2>1; then
		#
		# RDP app not found, auto-login to windows \
		# instances via RDP will fail when attempted
		#
		std_error_exit "rdesktop app not found. Login to RDP EC2 instances will fail. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
	fi
    #
    # <-- end function ec2cli_precheck-windows -->
    #
}

function convert_time(){
    # time format conversion (http://stackoverflow.com/users/1030675/choroba)
    num=$1
    min=0
    hour=0
    day=0
    if((num>59));then
        ((sec=num%60))
        ((num=num/60))
        if((num>59));then
            ((min=num%60))
            ((num=num/60))
            if((num>23));then
                ((hour=num%24))
                ((day=num/24))
            else
                ((hour=num))
            fi
        else
            ((min=num))
        fi
    else
        ((sec=num))
    fi
    echo "$day"d,"$hour"h,"$min"m
    #
    # <-- end function convert_time -->
    #
}

function convert_time_months(){
    # time format conversion (http://stackoverflow.com/users/1030675/choroba)
    num=$1
    min=0
    hour=0
    day=0
    mo=0
    if((num>59));then
        ((sec=num%60))
        ((num=num/60))
        if((num>59));then
            ((min=num%60))
            ((num=num/60))
            if((num>23));then
                ((hour=num%24))
                ((day=num/24))
                ((num=num/24))
                if((num>30)); then
                  ((day=num%31))
                  ((mo=num/30))
              else
                  ((day=num))
              fi
            else
                ((hour=num))
            fi
        else
            ((min=num))
        fi
    else
        ((sec=num))
    fi
    if (( $mo > 0 )); then
        echo "$mo"m,"$day"d
    else
        echo "$day"d,"$hour"h,"$min"m
    fi
    #
    # <-- end function convert_time -->
    #
}

function adjust_units(){
    ## adjusts size and units of disk based on inc of 1024 ##
    local sum="$1"      # raw sum
    local adj_sum
    local unit
    #1048576
    if [ $sum -gt $((1024*1024)) ]; then
        adj_sum=$(echo "scale=$FLOAT_DECIMAL; $sum/1024/1024" | bc)
        unit="PB"
    elif [ $sum -gt 1024 ]; then
        adj_sum=$(echo "scale=$FLOAT_DECIMAL; $sum/1024" | bc)
        unit="TB"
    else
        adj_sum=$sum
        unit="GB"
    fi
    echo "$adj_sum $unit"
}

function print_header(){
    ## print formatted report header ##
    local title="$1"
    local width="$2"
    local reportfile="$3"
    #
    printf "%-10s %*s" $(echo -e ${frame}) "$(($width - 1))" '' | tr ' ' _ | indent02 > $reportfile
    echo -e "${body}" >> $reportfile
    echo -ne ${title} >> $reportfile
    echo -e "${frame}" >> $reportfile
    printf '%*s' "$width" '' | tr ' ' _  | indent02 >> $reportfile
    echo -e "${body}" >> $reportfile
}

function print_footer(){
    ## print formatted report footer ##
    local footer="$1"
    local width="$2"
    #
    printf "%-10s %*s\n" $(echo -e ${frame}) "$(($width - 1))" '' | tr ' ' _ | indent02
    echo -e "${body}"
    echo -ne $footer | indent10
    echo -e "${frame}"
    printf '%*s\n' "$width" '' | tr ' ' _ | indent02
    echo -e "${body}"
}

function ec2cli_attach_volume(){
    # vars
    local CHOICE              # user selection
    local DEFAULTDEV          # default device
    local DEVICE
    local tmpVOLID
    local tmpINSTANCEID
    local INSTANCEID
    local REGION=$1
    local MAXCT               # array length
    local msg                 # msg string
    local VALID               # loop break
    local VOLID

    ## choose volume ##---------------------------------------------------
    echo -e "\n${BOLD}Volume choices: ${UNBOLD}$REGION\n" | indent18
    ec2cli_list_volumes $REGION > .text-output0.tmp
    grep "vol-" .text-output0.tmp > .text-output1.tmp

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a VOLUMES < .text-output1.tmp

    # array max length
    MAXCT=${#VOLUMES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0
    while (( i < $MAXCT )); do
            echo "($i): ""${VOLUMES[$i]}" >> .arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header display choices from array
    echo -e "\n     VolumeID      GB  State     Attached  InstanceId  VolType   Avail-Zone  Description"
    echo -e "     ------------  --  --------  --------  ----------  --------  ----------  ----------------------------"

    # values
    awk  '{ printf "%-4s %-13s %-3s %-9s %-9s %-11s %-9s %-11s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12}' .arrayoutput.tmp

    # Enter control structure to get user selection and validate
    VALID=0 # set loop break

    while [ $VALID -eq 0 ]; do
        # read volume choice in from user
        echo ""
        read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
        echo ""
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
            # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done

    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpVOLID=${VOLUMES[$CHOICE]}
    VOLID=$(echo $tmpVOLID | cut -c 1-12)
    echo "Volume "$VOLID" chosen."

    # clean up
    rm .text-output0.tmp .text-output1.tmp .arrayoutput.tmp

    ## choose instance ## ------------------------------------------------
    echo -e "\n${BOLD}EC2 Instance choices: ${UNBOLD}$REGION\n" | indent18
    ec2cli_list_instances $REGION > .text-output0.tmp
    grep "i-" .text-output0.tmp > .text-output1.tmp

    # Use built-in IFS to read in all lines in tmp file
    IFS=$'\n' read -d '' -r -a INSTANCES < .text-output1.tmp

    # array max length
    MAXCT=${#INSTANCES[*]} # keep in mind, IFS starts array index at 0

    # load output choice array
    i=0
    while (( i < $MAXCT )); do
            echo "($i): ""${INSTANCES[$i]}" >> .arrayoutput.tmp
            i=$(( $i+1 ))
    done

    # header to display choices from array
    echo -e "\n     InstanceId    Type     State    SecurityGroup    Root-Volume     Version"
    echo -e "     ----------- ---------  -------  --------------   ------------   ---------"

    # values
    awk  '{ printf "%-4s %-11s %-10s %-8s %-16s %-14s %-9s \n", \
        $1, $2, $3, $4, $5, $6, $7}' .arrayoutput.tmp

    # Enter control structure to get user selection and validate
    VALID=0 # loop break
    while [ $VALID -eq 0 ]; do
            # read volume choice in from user
            echo ""
            read -p "${yellow}  Enter # of choice or hit return for default [0]: ${reset}" CHOICE
            echo ""
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
            else
                    # valid user entry, exit loop
                    VALID=1
            fi
    done

    # assign volume to choice
    if [ -z "$CHOICE" ]; then
            # CHOICE is blank, assign to default
            CHOICE=0
    fi

    tmpINSTANCEID=${INSTANCES[$CHOICE]}
    INSTANCEID=$(echo $tmpINSTANCEID | cut -c 1-10)
    echo -e "Instance "$INSTANCEID" chosen.\n"

    # clean up
    rm .text-output0.tmp .text-output1.tmp .arrayoutput.tmp

    ## choose device ## --------------------------------------------------
    read -p  "${yellow}  Enter device to mount to [/dev/sda1]:  ${reset}" DEVICE
    DEFAULTDEV="/dev/sda1"

    if [ -z "$DEVICE" ]
    then
      DEVICE=$DEFAULTDEV
    else
      DEVICE=$DEVICE
    fi

    # execute
    echo -e "\nAttaching volume.....\n"
    aws ec2 --profile $PROFILE attach-volume \
        --volume-id $VOLID \
        --instance-id $INSTANCEID \
        --device $DEVICE \
        --output table
    ## FIXME: capture error conditions if attach fails
    ## send to $msg

    # log and exit
    if [[ "cat $msg | grep error" ]]; then
        # errors while attaching
        std_error_exit "$msg" $E_MISC
    else
        std_message "Volume $VOLID attached to instance $INSTANCEID in region $REGION." INFO
    fi
    #
    # <-- end function ec2cli_attach_volume -->
    #
}

function ec2cli_create_images(){
    # vars
    local REGION=$1         # aws region
    local CHOICE            # variable to hold user choice
    local DESCRIPTION       # user provided description for newly created image
    local INSTANCEID        # instance chosen for image creation
    local MAXCT             # max number of values in array
    local NOW               # date, formatted
    local NAME              # user provided name for newly created image
    local VALID             # loop break

    # pull json info, all instances in region
    aws ec2 describe-instances --region $REGION --profile $PROFILE --output json > .jsonoutput.tmp

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' .jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}          # count instances found

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_create_images: attempt to create AMI image"
        std_message "No EC2 instances found in region $REGION." INFO
        return
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' .jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' .jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' .jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' .jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' \
            .jsonoutput.tmp | cut -c 1-15) )
    # limit length of tag fields to 20 chars. NOTE: ARRAY ASSIGNMENT NOT WORKING CORRECTLY
    ARR_TAG=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' \
            .jsonoutput.tmp | cut -c 1-20) )

    # > 0 instances in region, print region identifier
    printf "\n${white}${BOLD}EC2 Instances${UNBOLD}${reset} : $REGION\n\n" | indent18

    # output table of json array
    i=0
    for id in ${ARR_ID[*]}; do
        echo "($i): "${ARR_ID[$i]} ${ARR_TYPE[$i]} ${ARR_STATE[$i]} ${ARR_SG[$i]} \
              ${ARR_DEV[$i]} ${ARR_TAG[$i]} >> .arrayoutput.tmp
        # incr ct
        i=$(( $i+1 ))
    done

    # display choices from array
    echo -e "       InstanceID           Type       State    SecurityGroup    Root-Volume            Description"
    echo -e "       -------------------  ---------  -------  ---------------  ---------------------  -------------------------"
    # values
    awk  '{ printf "%-6s %-20s %-10s %-8s %-16s %-22s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .arrayoutput.tmp
    # footer
    printf "\nTotal Instances in region [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n" | indent10

    # get user input while checking type and range
    VALID=0    # set loop break
    while [ $VALID -eq 0 ]; do
            # read choice in from user
            echo ""
            read -p "${yellow}  Enter instance # to create Amazon Machine Image (AMI) [quit]: ${reset}" CHOICE
            echo ""

            # assign instance to choice
            if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
                    # invalid user entry
                    echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
                    ### FIXME:  Fails if enter integer with 2 digits ###
            else
                    if [[ -z "$CHOICE" ]]; then
                            # CHOICE is blank, clean up and assign default [quit]
                            rm .arrayoutput.tmp
                            return
                            #exit $E_USER_CANCEL
                    else
                            # valid user entry, exit loop
                            VALID=1
                    fi
            fi
    done

    ## retrieve tag values Description, Name ##
    INSTANCEID=${ARR_ID[$CHOICE]}
    # retrieve json object for selected instance
    aws ec2 --profile $PROFILE describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    NOW=$(date +"%Y-%m-%dT%H:%M:%S")    # date + 24 hr time
    TIME=$(date +"%H.%M.%S")            # 24 hr time stamp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' .jsoninstance.tmp) )

    # search thru array of tags assoc with this instances
    NAME=""             # initialize
    DESCRIPTION=""      # initialize
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name, map to description
        if [ $key == "Name" ] || [ $key == "name" ]; then
            DESCRIPTION="$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)""($INSTANCEID)"
        fi
        # get description
        #if [ $key == "Description" ] || [ $key == "description" ]; then
        #    #DESCRIPTION=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
        #    DESCRIPTION="InstanceId_"$INSTANCEID  # STUB until issue 33 permanent fix
        #fi
        # increment
        i=$(( $i+1 ))
    done

    ## defaults if no tags ##
    if [ "$NAME" == "" ]; then
        # no name tag exists, append unique 24 hr time stamp
        NAME="AMI."$TIME
    fi
    if [ "$DESCRIPTION" == "" ]; then
        # no description tag exists
        DESCRIPTION="InstanceId_"$INSTANCEID
    fi

    # create image
    aws ec2 --profile $PROFILE create-image \
        --region $REGION \
        --instance-id $INSTANCEID \
        --name "$NAME" \
        --description "$DESCRIPTION" \
        --output table

    # user msg, locate after ec2 create-image called in case of failure
    echo -e "\n** Amazon Machine Image creation start **\n" | indent02
    echo -e "${white}AMI Name :${reset} "$NAME | indent02
    echo -e "${white}AMI Description :${reset} "$DESCRIPTION | indent02
    echo ""
    # log
    std_logger "INFO:  AMI image [$NAME] creation start"

    # clean up
    rm .jsonoutput.tmp .arrayoutput.tmp .jsoninstance.tmp
    #
    # <-- end function ec2cli_create_images -->
    #
}

function ec2cli_create_snapshot(){
    # vars
    local i                 # counter
    local REGION=$1
    local NOW="$(date +"%Y-%m-%d.T%H:%M")"
    local PROGRESSMSG="Snapshot creation started... "
    local VALID             # loop break
    local GVALID            # global valid for creating more than 1 snapshot

    GVALID=0
    while [ $GVALID -eq 0 ]; do
        #
        ### choose volume ###
        #
        # json object of all ebs volumes in region
        aws ec2 --profile $PROFILE describe-volumes --region $REGION --output json > .jsonoutput.tmp
        ARR_ID=( $(jq -r .Volumes[].VolumeId .jsonoutput.tmp) )
        MAXCT=${#ARR_ID[*]}
        if [[ $MAXCT -eq 0 ]]; then
            # no ebs volumes to snapshot, exit
            rm .jsonoutput.tmp
            std_error_exit "No EBS volumes in region $REGION. Exiting." $E_DEPENDENCY
        fi

        # volumes exist in region, process remainder of json object
        ARR_SIZE=( $(jq -r .Volumes[].Size .jsonoutput.tmp) )
        ARR_STATE=( $(jq -r .Volumes[].State .jsonoutput.tmp) )
        ARR_INSTANCE=( $(jq -r .Volumes[].Attachments[].InstanceId .jsonoutput.tmp) )
        ARR_TYPE=( $(jq -r .Volumes[].VolumeType .jsonoutput.tmp) )
        ARR_ENCRYPT=( $(jq -r .Volumes[].Encrypted .jsonoutput.tmp) )
        ARR_AZ=( $(jq -r .Volumes[].AvailabilityZone .jsonoutput.tmp) )
        ARR_TAG=( $(jq -r .Volumes[].Tags[0].Value .jsonoutput.tmp | cut -c 1-20) )

        # display choices
        printf "\n${white}${BOLD}EBS Volumes${UNBOLD}${reset} : $REGION\n\n" | indent18
        # create table of json array
        i=0
        for id in ${ARR_ID[*]}; do
            echo "($i): "${ARR_ID[$i]} ${ARR_SIZE[$i]} ${ARR_STATE[$i]} ${ARR_INSTANCE[$i]} \
                  ${ARR_TYPE[$i]} ${ARR_AZ[$i]} ${ARR_TAG[$i]} >> .arrayoutput.tmp
            # incr ct
            i=$(( $i+1 ))
        done
        # display choices from array
        echo -e "     VolumeID               GB  State     InstanceId           VolType   Avail-Zone  Tag"
        echo -e "     ---------------------  --  --------  -------------------  --------  ----------  --------------------"
        # values
        awk  '{ printf "%-4s %-22s %-3s %-9s %-20s %-9s %-11s %-2s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .arrayoutput.tmp
        # footer
        printf "\nTotal Volumes in region [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n" | indent10
        # clean up
        rm .jsonoutput.tmp .arrayoutput.tmp

        # get user input while checking type and range
        VALID=0    # set loop break
        while [ $VALID -eq 0 ]; do
                # read choice in from user
                echo ""
                read -p "${yellow}  Enter choice for hit return to quit [quit]: ${reset}" CHOICE
                echo ""

                # assign instance to choice
                if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
                        # invalid user entry
                        echo "You must enter an integer number between 0 and $(( $MAXCT-1 )) or quit."
                        ### FIXME:  Fails if enter integer with 2 digits ###
                else
                        if [[ -z "$CHOICE" ]]; then
                                # CHOICE is blank, assign default [quit]
                                return
                        else
                                # valid user entry, exit loop
                                VALID=1
                        fi
                fi
        done
        # assign vol ID to be snapshotted
        VOLID=${ARR_ID[$CHOICE]}

        ### create snapshot ###
        # description = concatenate volume date + Name tag
        NAMETAG=$(aws ec2 --profile $PROFILE describe-volumes \
                --region $REGION \
                --volume-id  $VOLID \
                --query 'Volumes[*].[Tags[0].Value]' \
                --output text)
        DESCRIPTION=$NOW", ""$NAMETAG"
        # start snapshot, output msg
        aws ec2 --profile $PROFILE create-snapshot \
                --output table \
                --region $REGION \
                --volume-id $VOLID \
                --description "$DESCRIPTION"
        # log, user msg
        std_message "Creating snapshot of volume [$VOLID] in region $REGION." INFO

        # option to create more snapshots
        echo ""
        read -p "${yellow}  Create another snapshot? [quit]: ${reset}" CHOICE
        echo ""
        if [[ -z "$CHOICE" ]]; then
                # CHOICE is blank, assign default (quit)
                GVALID=1
                return
        else
            case $CHOICE in
            y | Y | yes | Yes)
                GVALID=0
                ;;
            *)
                GVALID=1
                return
                ;;
            esac
        fi
    # end global while loop
    done
    #
    # <-- end function ec2cli_create_snapshot -->
    #
}

function ec2cli_create_tag(){
    local region="$1"
    local resource_id="$2"
    local KEY
    local VALID
    local VALUE

    # resource
    if [ ! $resource_id ]; then
        echo -e "\n  Enter the resource ID to tag:"
        read -p "${yellow}  ResourceId: ${reset}" resource_id
        echo ""
    fi

    case $resource_id in
        *\ * )
            echo "Resource ID cannot contain spaces or special characters."
        ;;
    esac
    # tag components:
    VALID=0    # set loop break
    while [[ $VALID -eq 0 ]]; do
        # get user input [KEY] while checking contents
        echo -e "\n  Enter the key name of the tag to create or update:"
        read -p "${yellow}  Key: ${reset}" KEY
        echo ""
        if [[ "$KEY" =~ \ |\' ]]; then
            echo "Key cannot contain spaces or special characters."
        else
            # get user input [keyvalue]
            echo -e "\n  Enter the tag value:"
            read -p "${yellow}  Tag Value: ${reset}" VALUE
            echo ""
            VALID=1    # break
        fi
    done

    # create tag
    aws ec2 --profile $PROFILE --region $region create-tags \
        --resources $resource_id \
        --tags Key="$KEY",Value="$VALUE"

    # Output list of all tags
    ec2cli_list_tags  $region $resource_id
    #
    # <-- end function ec2cli_cretae-tag -->
    #
}

function ec2cli_list_instances(){
    # vars
    local TOTAL             # region EC2 instance count
    local REGION=$1         # region identifier
    local NOW               # date, formatted
    local LAUNCHTIME        # date/time launched from json object
    local EPOCHLT           # LAUNCHTIME in epoch seconds
    local RUNSECS           # runtime in sec
    local MAXCT             # max length of array (json object)
    local total_width="145" # max width of cli output

    # pull json info, all instances in region
    aws ec2 --profile $PROFILE describe-instances --region $REGION --output json > .jsonoutput.tmp

    # load fields into respective arrays
    ARR_STATE=( $(jq -r '.Reservations[].Instances[].State.Name' .jsonoutput.tmp) )
    MAXCT=${#ARR_STATE[*]}    # count instances found

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_list_instances: list instances"
        std_message "No EC2 instances found in region $REGION." INFO
        return
    fi

    # instances > 0, parse remainder of json object
    ARR_IP=( $(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp) )
    ARR_LT=( $(jq -r '.Reservations[].Instances[].LaunchTime' .jsonoutput.tmp) )
    ARR_ID=( $(jq -r '.Reservations[].Instances[].InstanceId' .jsonoutput.tmp) )
    ARR_TYPE=( $(jq -r '.Reservations[].Instances[].InstanceType' .jsonoutput.tmp) )
    ARR_DEV=( $(jq -r '.Reservations[].Instances[].BlockDeviceMappings[0].Ebs.VolumeId' .jsonoutput.tmp) )
    # limit security grp name to 15 chars
    ARR_SG=( $(jq -r '.Reservations[].Instances[].SecurityGroups[0].GroupName' .jsonoutput.tmp | cut -c 1-15) )
    # limit length of tag fields to 20 chars
    ARR_TAG=( $(jq -r '.Reservations[].Instances[].Tags[0].Value' .jsonoutput.tmp | cut -c 1-20) )

    #
    # instances in region.  test if running instances
    #

    if [[ "$(printf '%s\n' "${ARR_STATE[@]}" | grep "running")" ]] || \
        [[ "$(printf '%s\n' "${ARR_STATE[@]}" | grep "stopping")" ]]; then
        #
        # at least 1 running instance found, calc runtime
        i=0     # counter
        r=0     # running instance count
        s=0    # stopped instance count

        while (( i < $MAXCT )); do
            if [[ "${ARR_STATE[$i]}" == "running" ]] || [[ "${ARR_STATE[$i]}" == "stopping" ]]; then
                # calc now in UTC epoch seconds
                NOW=$(date -u +%s)

                # calc launchtime
                LAUNCHTIME="${ARR_LT[$i]}"
                EPOCHLT=$(date -d"$LAUNCHTIME" +%s)
                RUNSECS=$(( $NOW-$EPOCHLT ))    # runtime (seconds)
                RT[$i]=$(convert_time $RUNSECS)
                # track # running instances
                r=$(( $r+1 ))
            else
                # if not running, blank runtime
                RT[$i]="-"
            fi
            # convert public IP format
            if [ "${ARR_IP[$i]}" == "null" ]; then
                # alter IP format
                ARR_IP[$i]="-"
            fi
            i=$(( $i+1 ))    # incr counter
        done
        # format stats
        s=${BOLD}$(( $MAXCT - $r ))${UNBOLD}
        r=${BOLD}$r${UNBOLD}

        # print title
        printf "\n${title}EC2 INSTANCES${body} : $REGION  |  * sorted\n" | indent18

        # print header
        print_header "InstanceId Type State SecurityGroup Root-Volume Public-IP RunTime* Tag" $total_width .body.tmp


        #
        # output table of json array
        #
        i=0
        while (( i < $MAXCT )); do
            echo "${ARR_ID[$i]}  ${ARR_TYPE[$i]}  ${ARR_STATE[$i]} ${ARR_SG[$i]}  \
                ${ARR_DEV[$i]}  ${ARR_IP[$i]}  ${RT[$i]}  ${ARR_TAG[$i]}" >> sort.tmp
            i=$(( $i+1 ))
        done
        cat sort.tmp | sort -k7 -n >> .body.tmp
        rm sort.tmp    # clean up
        #
        # print and format output
        #
        awk  '{ printf "%-22s %-13s %-10s %-18s %-24s %-16s %-15s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9}' .body.tmp | indent02
        # print footer
        print_footer "Total Instances [$REGION]: ${title}$MAXCT${body}  |  ${title}$r${body} running, ${title}$s${body} stopped" $total_width

    else
        ### -- no running instances -- ###
        total_width="110"
        printf "\n${white}${BOLD}EC2 INSTANCES${UNBOLD}${reset} : $REGION\n" | indent18
        print_header "InstanceId* Type State SecurityGroup Root-Volume Tag" $total_width .body.tmp
        #
        # output table of json array
        #
        i=0
        while (( i < $MAXCT )); do
            echo "${ARR_ID[$i]} ${ARR_TYPE[$i]} ${ARR_STATE[$i]} ${ARR_SG[$i]} \
                  ${ARR_DEV[$i]} ${ARR_TAG[$i]}" >> .body.tmp
            # incr ct
            i=$(( $i+1 ))
        done
            # print and format output
            awk  '{ printf "%-22s %-12s %-9s %-16s %-23s %-11s %-2s %-2s %-2s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .body.tmp | indent02

        # print footer
        print_footer "Total Instances [$REGION]: ${title}$MAXCT${body}    *No running instances" $total_width
    fi

    # clean up
    rm .body.tmp .jsonoutput.tmp

    #
    # <-- end function ec2cli_list_instances -->
    #
}

function ec2cli_list_images(){
    # vars
    local i             # counter
    local REGION=$1     # region passed from global identifier
    local NUMLIST       # boolean parameter, 1 = output numbered list
    local MAXCT         # array length

    # print out numbered list of instances?
    if [[ $2 ]] && [[ $2 -eq 1 ]]; then NUMLIST=1; fi

    # retrieve json array
    aws ec2 --profile $PROFILE describe-images --region $REGION --output json --owner self > .jsonimages.tmp
    ARR_IMAGEID=( $(jq -r ".Images[].ImageId" .jsonimages.tmp) )
    MAXCT=${#ARR_IMAGEID[*]}    # values in array

    # test for 0 instances in region
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_list_images: list AMI images"
        std_message "No Amazon Machine Images found in region $REGION." INFO
        rm .jsonimages.tmp    # clean up
        return
    fi

    # images exist in region, retrieve all other values
    ARR_TYPE=( $(jq -r ".Images[].ImageType" .jsonimages.tmp) )
    ARR_VTYPE=( $(jq -r ".Images[].VirtualizationType" .jsonimages.tmp) )
    ARR_CREATEDATE=( $(jq -r ".Images[].CreationDate" .jsonimages.tmp) )
    ARR_SNAP=( $(jq -r ".Images[].BlockDeviceMappings[0].Ebs.SnapshotId" .jsonimages.tmp) )
    ARR_NAME=( $(jq -r ".Images[].Name" .jsonimages.tmp | cut -c 1-25) )    # limit to 25 chars
    ARR_DESCR=( $(jq -r ".Images[].Description" .jsonimages.tmp) )

    # convert date-time format to %Y-%m-%d.T%H:%M
    i=0     # initialize counter
    for date in ${ARR_CREATEDATE[*]}; do
        ARR_CREATEDATE[$i]=$(date -d${ARR_CREATEDATE[$i]}  +%Y-%m-%d.T%H:%M)
        # echo "Formatted create date is: "${ARR_CREATEDATE[$i]}    # TESTING
        # increment counter
        i=$(( $i+1 ))
    done

    # print header
    echo -ne "AMI-id CreateDateTime Type vType SnapshotId Description\n \
            ------------ -----------------  ------- -----  \
            ---------------------- -------------------------\n" > .header.tmp

    # create table of json array
    i=0
    for image in ${ARR_IMAGEID[*]}}; do
        echo "${ARR_IMAGEID[$i]} ${ARR_CREATEDATE[$i]} ${ARR_TYPE[$i]} \
            ${ARR_VTYPE[$i]} ${ARR_SNAP[$i]}"" ${ARR_DESCR[$i]}" >> .body.tmp
        i=$(( $i+1 ))
    done
    # sort and combine results
    cat .header.tmp > .output.tmp
    cat .body.tmp | sort -k +2 >> .output.tmp

    ## print and format output ##
    # header, region identifier
    printf "\n${white}${BOLD}AMAZON MACHINE IMAGES (AMI) :${UNBOLD}${reset} $REGION\n\n" | indent18
    # format output
    awk  '{ printf "%-13s %-18s %-8s %-6s %-23s %-10s %-2s %-2s %-2s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10}' .output.tmp | indent02
    # footer
    printf "\nTotal AMI Count [$REGION]: ${white}${BOLD}$MAXCT${UNBOLD}${reset}\n\n" | indent18

    # clean up
    rm .jsonimages.tmp .output.tmp .body.tmp
    #
    # <-- end function ec2cli_list_images -->
    #
}

function ec2cli_parse-instance-tag(){
    # vars
    local i             # counter
    local APP           # app tag key value
    local ENV           # env (environment) tag key value
    local INSTANCEID    # id of instance passed as $2
    local key           # key representing 1 tag
    local SEARCHKEY     # search instance tags to find this key
    local TAGVALUE      # value assoc with SEARCHKEY, if exists
    local REGION        # region identifier

    REGION=$1
    INSTANCEID=$2
    SEARCHKEY=$3
    ## retrieve tag values Description, Name ##
    # retrieve json object for selected instance
    aws ec2 --profile $PROFILE describe-instances \
        --region $REGION \
        --instance-ids $INSTANCEID \
        --output json > .jsoninstance.tmp
    TAGS=( $(jq -r '.Reservations[].Instances[].Tags[].Key' .jsoninstance.tmp) )

    # search thru array of tags assoc with this instances
    i=0                 # counter
    for key in ${TAGS[*]}; do
        # get Name
        if [[ $key == "$SEARCHKEY" ]]; then
            TAGVALUE=$(jq -r ".Reservations[].Instances[].Tags[$i].Value" .jsoninstance.tmp)
            echo $TAGVALUE
            return
        fi
        # increment
        i=$(( $i+1 ))
    done

    # clean up
    rm .jsoninstance.tmp
    #
    # <-- end function ec2cli_parse-instance-tag -->
    #
}

function ec2cli_rdp-login(){
	# vars
	local CHOICE                     # user selection variable
	local i                          # loop counter
	local IPADDRESS=$2               # public IP address of RDP windows instance
	local MAXCT                      # array size
    local USER                       # user entered userid
    local PASSWD                     # user entered passwd
	local SIZE="90%"                 # RDP session win size relative to client resolution
	local RDP_USER="Administrator"   # default rdp user, Win instance login
	local TARGET=$1                  # target EC2 instance for starting/ log in
	local VALID                      # loop break

	# verify login prereqs
	ec2cli_precheck-windows

	# load array with choices
	RDP_SIZE[0]="90%"
	RDP_SIZE[1]="1366x768"
	RDP_SIZE[2]="1400x860"
	RDP_SIZE[3]="1900x1000"
    RDP_SIZE[4]="2540x1360"
	# size of array
	MAXCT=${#RDP_SIZE[*]}

	i=0    # counter
	while (( i < $MAXCT )); do
        	echo "($i): ""${RDP_SIZE[$i]}"  >> .type.tmp
        	i=$(( $i+1 ))
	done

	# print window size choices
	echo -e "\n\n${BOLD}Select an RDP Session Window Size:${UNBOLD}\n"
	awk -F "  " '{ printf "%-4s %-20s \n", $1, $2}' .type.tmp
	# get user input while checking type and range
	VALID=0    # set loop break
	while [[ $VALID -eq 0 ]]; do
        	# read instance choice in from user
	        echo ""
        	read -p "${yellow}  Enter # RDP window resolution or hit return for relative size [90%]: ${reset}" CHOICE
	        echo ""

        	if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
				# invalid user entry
                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
        	else
				# valid user entry, exit loop
                VALID=1
        	fi
	done
	if [ -z "$CHOICE" ]
	then
        	# CHOICE is blank, default chosen
	        CHOICE=0
	fi
    # assign size
	SIZE=${RDP_SIZE[$CHOICE]}

	# log
	std_message "Starting RDP Session with $SIZE RDP window size on instance ($TARGET)." INFO

    # password
    if [[ ! $(env | grep -i REMOTE_RDP_PASSWD) ]]; then
            echo ""
            read -p "${yellow}  Enter the RDP user required for login to this windows instance: ${reset}" RDP_USER
            echo ""
            read -p "${yellow}  Enter the $RDP_USER password to establish an RDP login to this windows instance: ${reset}" REMOTE_RDP_PASSWD
            echo ""
    fi

	# Start rdp desktop session
	rdesktop -u $RDP_USER -p "$REMOTE_RDP_PASSWD" -g $SIZE -a "24" $IPADDRESS &

	### FIXME: Support multiple passwds. Solicit passwd from user or default to \
	### shell global env var (REMOTE_RDP_PASSWD) ###

    # clean up
    rm .type.tmp
    # log and exit
    std_logger "INFO: RDP Instance ($TARGET) started. RDP session size: $SIZE."
    exit 0
    #
    # <-- end function ec2cli_rdp-login -->
    #
}

function ec2cli_run_instances(){
	# vars
	local ACCESS                # flag if ssh access from login location
    local IPADDRESS       		# public IP of instance
	local KEY             		# name of ssh key (.pem file)
	local MAXCT           		# array length
	local MYCIDR           		# local IP of client running $pkg
	local NOW=$(date)     		# current time
	local OS              		# operating system of instance
	local PROGRESSTXT="EC2 Instance Starting Up.  Please wait... "
	local REGION=$1       		# target region
	local SSH_USER="ec2-user"   # default ssh user for login, Linux instance
	local TARGET                # instance to be started/ login
	local tmpID           		# temp holder for instance ID
	local VALID           		# loop break
    local i                     # loop counter

    #
	# choose instance -----------------
	#
	aws ec2 --profile $PROFILE describe-instances \
	        --region $REGION \
	        --output text \
	        --query "Reservations[*].Instances[*]. \
	            [InstanceId, \
	            InstanceType, \
	            State.Name, \
	            SecurityGroups[0].GroupName, \
	            BlockDeviceMappings[0].Ebs.VolumeId, \
	            PublicIpAddress, \
	            Tags[0].Value]" \
	>> .text-output1.tmp

	# Use built-in IFS to read in all lines in tmp file
	IFS=$'\n' read -d '' -r -a INSTANCES < .text-output1.tmp

	# calc array max length | test for 0 instances
	MAXCT=${#INSTANCES[*]} # IFS starts array index at 0
    if [[ $MAXCT = 0 ]]; then
        # no instances in region
        std_logger "INFO: function ec2cli_run_instances: attempt to run instances"
        std_message "No EC2 instances found in region $REGION" INFO
        return
    fi

    # header
    echo -e "\n${white}${BOLD}Available Instances${UNBOLD}${reset}: $REGION\n" | indent18
	# load output choice array
	i=0
	while (( i < $MAXCT )); do
	        echo "($i): ""${INSTANCES[$i]}" >> .arrayoutput.tmp
	        i=$(( $i+1 ))
	done

	# display choices from array
	echo -e "     InstanceID           Type       State    SecurityGroup    Root-Volume            PublicIP        Description"
	echo -e "     -------------------  ---------  -------  ---------------  ---------------------  --------------  -------------------------"

	# values
	awk  '{ printf "%-4s %-20s %-10s %-8s %-16s %-22s %-15s %-2s %-2s %-2s %-2s \n", \
	        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11}' .arrayoutput.tmp

	# get user input while checking type and range
	VALID=0    # set loop break

	while [ $VALID -eq 0 ]; do
	        # read choice in from user
	        echo ""
	        read -p "${yellow}  Enter instance # to start/ log in [quit]: ${reset}" CHOICE
	        echo ""

	        # assign instance to choice
	        if [[ -n ${CHOICE//[0-$(( $MAXCT-1 ))]/} ]]; then
	                # invalid user entry
	                echo "You must enter an integer number between 0 and $(( $MAXCT-1 ))."
	                ### FIXME:  Fails if enter integer with 2 digits ###
	        else
	                if [[ -z "$CHOICE" ]]; then
	                        # CHOICE is blank, clean up and assign default [quit]
                            rm .arrayoutput.tmp .text-output1.tmp
	                        exit $E_USER_CANCEL
	                else
	                        # valid user entry, exit loop
	                        VALID=1
	                fi
	        fi
	done
    # msg instance to start/ login | CONVERT TO JSON
	tmpID=${INSTANCES[$CHOICE]}
	TARGET=$(echo $tmpID | awk '{print $1}')
    # msg out
	std_message "Instance ($TARGET) selected." INFO
	#
	# network access check ------------
	#
	std_message "Verifying Network Access to ($TARGET). Please wait ..." INFO

	# retrieve secuirty group(s) of selected ec2 instance
	aws ec2 --profile $PROFILE describe-instances \
	        --region $REGION \
	        --output text \
	        --instance-id $TARGET \
	        --query 'Reservations[].Instances[].SecurityGroups[*].GroupId' > .secgrp-ids.tmp

	# discover local ip
	dig +short myip.opendns.com @resolver1.opendns.com > .myip.tmp
    MYCIDR="$(cat .myip.tmp)/32"

    # grab security group details
    aws ec2 --profile $PROFILE describe-security-groups \
        --output json \
        --region $REGION \
        --group-ids $(cat .secgrp-ids.tmp) > .jsonoutput.tmp
    ARR_PORT=( $(jq -r '.SecurityGroups[].IpPermissions[].ToPort' .jsonoutput.tmp) )
    ARR_IP=( $(jq -r '.SecurityGroups[].IpPermissions[].IpRanges[].CidrIp' .jsonoutput.tmp) )
    MAXCT=${#ARR_PORT[*]}

    i=0    # counter
    while (( i < $MAXCT )); do
        if [[ ${ARR_PORT[$i]} = 22 ]]; then
            if [[ ${ARR_IP[$i]} == "$MYCIDR" ]] || [[ ${ARR_IP[$i]} == "0.0.0.0/0" ]]; then
                ACCESS=1
                i=$MAXCT    # access found, break
            fi
        fi
        # incr counter
        i=$(( $i + 1 ))
    done

	if [[ $ACCESS = 1 ]]; then
	        # Access validated
			std_message "SSH access verified to instance ($TARGET). Proceeding..." INFO
	        # clean up
	        rm .myip.tmp .jsonoutput.tmp .secgrp-ids.tmp
	else
	        # No access from current login client location, clean up
	        rm .arrayoutput.tmp .text-output1.tmp .myip.tmp .jsonoutput.tmp .secgrp-ids.tmp
	        # log, exit
	        std_error_exit "No ssh access to instance ($TARGET). Please update security group settings. Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	#
	# start instance ------------------
	#
	# check to see if already started
    if [[ $(grep $TARGET .text-output1.tmp | grep running) ]]; then
        # instance already running, skip start
        std_message "Instance ($TARGET) already running.  Logging in..." INFO
    else
        # instance not running, attempt to start
	    aws ec2  --profile $PROFILE start-instances --region $REGION --output json --instance-ids $TARGET | jq .

	    # wait for instance to start, return after
	    aws ec2  --profile $PROFILE wait instance-running --region $REGION --instance-ids $TARGET &

	    # call function to show on screen while wait
	    ec2cli_spinner

	    # FIXME (HACK) | login delay: loop for i seconds, display counter
    	i=10    # count in seconds
	    echo -e "\n "

	    while (( i > 0 )); do
	        printf "\rInstance available in: ""$i"" seconds"
	        sleep 1
	        i=$(( i-1 ))
	    done
    fi

	#
	# Log in --------------------------
	#
    std_message "Authenticating to instance ($TARGET)..." INFO
	# retrieve json object for selected instance
	aws ec2  --profile $PROFILE describe-instances \
        --region $REGION \
        --output json \
		--instance-id $TARGET > .jsonoutput.tmp

	# discover public ip assignment
	IPADDRESS=$(jq -r '.Reservations[].Instances[].PublicIpAddress' .jsonoutput.tmp)
	#
	# validate IP as public
	if [[ $IPADDRESS == "null" ]]; then
		std_error_exit "No public IP address found for ($TARGET). Aborting (code $E_NETWORK_ACCESS)" $E_NETWORK_ACCESS
	fi

	# Check Windows or Linux
	OS=$(jq -r '.Reservations[].Instances[].Platform' .jsonoutput.tmp)

	if [[ $OS == "windows" ]]; then
			# windows instance, validate deps & log in via RDP
            # clean up
            rm .arrayoutput.tmp .text-output1.tmp .jsonoutput.tmp
			# windows login
            ec2cli_rdp-login $TARGET $IPADDRESS
	else
		# Linux instance, discover required access key
		KEY=$(jq -r '.Reservations[].Instances[].KeyName' .jsonoutput.tmp)".pem"

		# update log and login
		std_logger "INFO: Linux Instance ($TARGET) started. "
		ssh -i $SSH_KEYS/$KEY $SSH_USER@$IPADDRESS

		# clean up and exit
		rm .arrayoutput.tmp .text-output1.tmp .jsonoutput.tmp
    	exit 0
	fi
    #
    # <-- end function ec2cli_run_instances -->
    #
}

function ec2cli_list_securitygroups(){
    # vars
    local REGION=$1
    local TOTAL
    local total_width="130"
    # print region identifier
    printf "\n${title}SECURITY GROUPS${body} : $REGION\n\n" | indent18

    # print header
    print_header "GroupName Group-Id Ports Ports CidrIp VpcId Tag Description" $total_width .ec2-qv-securitygroups.tmp

    # output from aws
    aws ec2 --profile $PROFILE describe-security-groups \
        --output text \
        --region $REGION \
        --query "SecurityGroups[*]. \
            [GroupName, \
            GroupId, \
            IpPermissions[0].FromPort, \
            IpPermissions[0].ToPort, \
            IpPermissions[0].IpRanges[0].CidrIp, \
            VpcId, \
            Tags[0].Value, \
            Description]" \
    >> .ec2-qv-securitygroups.tmp

    # count total
    TOTAL=$(cat .ec2-qv-securitygroups.tmp | grep "sg-" | wc -l)

    # print and format output
    awk  '{ printf "%-20s %-13s %-6s %-7s %-19s %-14s %-20s %-20s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8}' .ec2-qv-securitygroups.tmp | indent02

    # print footer
    print_footer "${white}${BOLD}$TOTAL${UNBOLD}${reset} Security Groups in region [$REGION]" $total_width

    # clean up
    rm .ec2-qv-securitygroups.tmp
    #
    # <-- end function ec2cli_list_securitygroups -->
    #
}


function ec2cli_list_snapshots(){
    # vars
    local REGION=$1
    local sort_column="$2"
    local SUM
    local TOTAL
    local total_width=$(( $(tput cols) - 4 ))
    #
    # output from aws
    aws ec2 --profile $PROFILE describe-snapshots --owner self --output json --region $REGION > .jsonoutput.tmp

    # Sum size of all snapshots (footer)
    SUM=$(jq -r '.Snapshots | map(.VolumeSize) | add' .jsonoutput.tmp)

    if [ $SUM == "null" ] || [ $SUM -eq 0 ]
    then
        # print footer if no snapshots found
        std_message "${title}0${body} snapshots in region [$REGION], total ${title}0${body} GB" "INFO"  | indent10
    else
        # print and format output
        sp="${frame}|${body}"       # separator

        if (( $(tput cols) >= "160" )); then
            FULL_CLI="True"
            std_logger "[INFO]: FULL_CLI set to True, Full width output"
            total_width="154"
        else
            total_width="132"
        fi
        # snapshots found, print region identifier
        printf "\n${title}SNAPSHOTS${body} : $REGION  |  $ast*${body}sorted\n" | indent25

        if [ $FULL_CLI ]; then
            print_header "$sp  SnapId $sp Size $sp CreateTime* $sp State $sp Prog $sp Encrypted $sp VolumeId $sp Tag $sp Description $sp" $total_width  .ec2-qv-snapshots.tmp
        else
            print_header "$sp SnapId $sp Size $sp CreateTime* $sp State $sp Prog $sp Encrypted $sp VolumeId $sp Description $sp" $total_width .ec2-qv-snapshots.tmp
        fi

        # parse json
        ARR_ID=( $(jq -r '.Snapshots[].SnapshotId' .jsonoutput.tmp) )
        ARR_SIZE=( $(jq -r '.Snapshots[].VolumeSize' .jsonoutput.tmp) )
        ARR_CTIME=( $(jq -r '.Snapshots[].StartTime' .jsonoutput.tmp) )
        ARR_VID=( $(jq -r '.Snapshots[].VolumeId' .jsonoutput.tmp) )
        ARR_STATE=( $(jq -r '.Snapshots[].State' .jsonoutput.tmp) )
        ARR_PROG=( $(jq -r '.Snapshots[].Progress' .jsonoutput.tmp) )
        ARR_ENCRYPT=( $(jq -r '.Snapshots[].Encrypted' .jsonoutput.tmp) )
        ARR_DESC=( $(jq -r '.Snapshots[].Description' .jsonoutput.tmp | cut -c 1-20) )
        # limit length of tag fields to 20 chars
        ARR_TAG=( $(jq -r '.Snapshots[].Tags[0].Value' .jsonoutput.tmp | cut -c 1-20) )


        MAXCT=${#ARR_ID[*]}    # count snapshots found

        # output table of json array
        i=0
        if [ $FULL_CLI ]; then
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_PROG[$i]} $sp $( if $(echo ${ARR_ENCRYPT[$i]}) == "true"; then echo "Encypt"; else echo "-"; fi ) $sp \
                      ${ARR_VID[$i]} $sp ${ARR_TAG[$i]} $sp ${ARR_DESC[$i]} $sp" >> .body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        else
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_ID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_PROG[$i]} $sp $( if $(echo ${ARR_ENCRYPT[$i]}) == "true"; then echo "Encrypted"; else echo "-"; fi ) $sp \
                      ${ARR_VID[$i]} $sp ${ARR_DESC[$i]} $sp" >> .body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
        fi

        if [ ! $sort_column ]; then
            sort_column="date"
        fi
        case $sort_column in
            id | Id | ID | SnapshotId)
                column=2; cat .body.tmp | sort -k"$column" -n >> .ec2-qv-snapshots.tmp;;
            size | Size)
                column=4; cat .body.tmp | sort -k"$column" -n >> .ec2-qv-snapshots.tmp;;
            date)
                column=5; cat .body.tmp | sort -k6 -r >> .ec2-qv-snapshots.tmp;;
        esac

        # size, unit calcs of raw volumes snapshotted
        RETURN=$(adjust_units $SUM)
        ASUM=$(echo $RETURN | awk '{print $1}')
        UNIT=$(echo $RETURN | awk '{print $2}')
        # estimated actual size, units on disk
        ESTIMATE="$(( $SUM / 5 ))"    # 20% estimated real size on disk
        RETURN=$(adjust_units $ESTIMATE)
        ESUM="${BOLD}$(echo $RETURN | awk '{print $1}')${UNBOLD}"
        EUNIT=$(echo $RETURN | awk '{print $2}')
        if [ $FULL_CLI ]; then
            awk  '{printf "%-2s %-23s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-5s %-2s %-9s %-2s %-22s %-2s %-20s %-2s %-20s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19}' .ec2-qv-snapshots.tmp | indent02
        else
            awk  '{printf "%-2s %-23s %-2s %-5s %-2s %-12s %-2s %-10s %-2s %-5s %-2s %-10s %-2s %-22s %-2s %-20s %-2s \n", \
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' .ec2-qv-snapshots.tmp | indent02
        fi
        # print footer
        print_footer "${title}$MAXCT${UNBOLD}${body} snapshots in region [$REGION], total ${title}$ASUM${UNBOLD}${body} $UNIT | ${title}$ESUM${UNBOLD}${body} $EUNIT on disk (est)" $total_width

        rm .ec2-qv-snapshots.tmp .body.tmp .jsonoutput.tmp
    fi
    #
    # <-- end function ec2cli_list_snapshots -->
    #
}

function ec2cli_spinner(){
    # vars
    local PROGRESSTXT="Please wait..."
    # visual progress marker function
    # http://stackoverflow.com/users/2869509/wizurd
    # vars
    local pid=$!
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf "\r$PROGRESSTXT[%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    #
    # <-- end function ec2cli_spinner -->
    #
}


function ec2cli_list_subnets(){
    # vars
    local TOTAL
    local REGION=$1

    # print region identifier
    printf "\n${white}${BOLD}SUBNETS${UNBOLD}${reset} : $REGION\n\n" | indent18
    # print header
    echo -ne "Name SubnetId Public CIDR-Block #IPs AvailZone Default\n \
    ------------- --------------- ------ --------------- ---- ---------- -------\n" > .ec2-qv.tmp
    # output from aws
    aws ec2 --profile $PROFILE describe-subnets \
        --output text \
        --region $REGION \
        --query "Subnets[*]. \
            [Tags[0].Value, \
            SubnetId, \
            MapPublicIpOnLaunch, \
            CidrBlock, \
            AvailableIpAddressCount, \
            AvailabilityZone, \
            DefaultForAz]" | sort -k +4n >> .ec2-qv.tmp
    # count total
    TOTAL=$(cat .ec2-qv.tmp | grep "subnet-" | wc -l)
    # print and format output
    awk  '{ printf "%-15s %-17s %-7s %-16s %-6s %-12s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7}' .ec2-qv.tmp | indent02
    # print footer
    printf "\nTotal Subnets, [$REGION]: ${white}${BOLD}$TOTAL${UNBOLD}${reset}\n\n" | indent15
    # clean up
    rm .ec2-qv.tmp
    #
    # <-- end function ec2cli_list_subnets -->
    #
}

function ec2cli_list_tags(){
    # vars
    local region="$1"
    local resource_id="$2"

    if [[ ! $resource_id ]]; then
        echo " "
        aws ec2 --profile $PROFILE describe-tags --output table
        echo " "
    else
        # resource ID given by user
        tags=""
        tags=$(aws ec2 --profile $PROFILE describe-tags \
                --filters="Name=resource-id,Values=$resource_id" \
                --region $region \
                --output json | grep $resource_id)
        if [[ ! $tags ]]; then
            # no tags exist for resource
            std_message "No tags found for resource [$resource_id]." INFO
            echo -e "  ${BOLD}NOTE${UNBOLD}:   You must provide a regioncode if the resource is not" | indent04
            echo -e "    in your default region.\n" | indent10
        else
            echo -e "\nTags for AWS ResourceId:  ${BOLD}$resource_id${UNBOLD} | $region\n" | indent04
            aws ec2 --profile $PROFILE describe-tags \
                --filters="Name=resource-id,Values=$resource_id" \
                --region $region \
                --output table
            echo -e "\n"
        fi
    fi
    #
    # <-- end function ec2cli_list_tags -->
    #
}

function ec2cli_list_volumes(){
    # vars
    local REGION=$1
    local SUM
    local TOTAL
    local total_width
    local sp="${frame}|${body}"       # separator
    #
    # determine output size
    if (( $(tput cols) >= "170" )); then
        FULL_CLI="True"
        total_width="165"
    elif (( $(tput cols) >= "146" )); then
        MED_CLI="True"
        std_logger "[INFO]: MED_CLI set to True, Full width output"
        total_width="140"
    else
        total_width="126"
    fi
    # sum total size of all volumes (display in footer)
    aws ec2 --profile $PROFILE describe-volumes --region $REGION --output json > .jsonoutput.tmp

    # determine size of all volumes returned
    SUM=$(jq -r '.Volumes | map(.Size) | add' .jsonoutput.tmp)

    if [ $SUM == "null" ] || [ $SUM -eq 0 ]
    then
        # print footer if no volumes found
        std_message "${title}0${body} volumes in region [$REGION], total ${title}${BOLD}0${body} GB" "INFO"
    else
        #
        # volumes found, print region identifier
        #
        printf "\n${title}EBS VOLUMES${body} : $REGION\n" | indent18

        # parse json
        ARR_VID=( $(jq -r '.Volumes[].VolumeId' .jsonoutput.tmp) )
        ARR_SIZE=( $(jq -r '.Volumes[].Size' .jsonoutput.tmp) )
        ARR_CTIME=( $(jq -r '.Volumes[].CreateTime' .jsonoutput.tmp) )
        ARR_STATE=( $(jq -r '.Volumes[].Attachments[0].State' .jsonoutput.tmp) )
        ARR_ATTACH=( $(jq -r '.Volumes[].Attachments[0].InstanceId' .jsonoutput.tmp) )
        ARR_IID=( $(jq -r '.Volumes[].VolumeId' .jsonoutput.tmp) )
        ARR_VTYPE=( $(jq -r '.Volumes[].VolumeType' .jsonoutput.tmp) )
        ARR_AZ=( $(jq -r '.Volumes[].AvailabilityZone' .jsonoutput.tmp | cut -c 1-20) )
        # limit length of tag fields to 20 chars
        ARR_TAG=( $(jq -r '.Volumes[].Tags[0].Value' .jsonoutput.tmp | cut -c 1-20) )

        MAXCT=${#ARR_VID[*]}    # count snapshots found

        # print and format output
        i=0
        if [ $FULL_CLI ]; then
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_ATTACH[$i]} $sp ${ARR_IID[$i]} $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_AZ[$i]} $sp ${ARR_TAG[$i]} $sp" >> .body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Attached $sp InstanceId $sp VolType $sp Avail-Zone $sp Tag $sp" $total_width .ec2-qv-volumes.tmp
            # sort body text
            cat .body.tmp | sort -k5 -r >> .ec2-qv-volumes.tmp
            awk  '{ printf "%-2s %-23s %-2s %-6s %-2s %-12s %-2s %-10s %-2s %-20s %-2s %-23s %-2s %-10s %-2s %-11s %-2s %-22s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19}' .ec2-qv-volumes.tmp | indent02
        elif [ $MED_CLI ]; then
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_ATTACH[$i]} $sp ${ARR_IID[$i]} $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_AZ[$i]} $sp" >> .body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Attached $sp InstanceId $sp VolType $sp Avail-Zone $sp" $total_width .ec2-qv-volumes.tmp
            # sort body text
            cat .body.tmp | sort -k5 -r >> .ec2-qv-volumes.tmp
            awk  '{ printf "%-2s %-23s %-2s %-6s %-2s %-12s %-2s %-10s %-2s %-20s %-2s %-23s %-2s %-10s %-2s %-11s %-2s \n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' .ec2-qv-volumes.tmp | indent02
        else
            # output table of json array
            while (( i < $MAXCT )); do
                echo "$sp ${ARR_VID[$i]} $sp ${ARR_SIZE[$i]} $sp $(date --date=${ARR_CTIME[$i]} +"%Y-%m-%d") $sp \
                      ${ARR_STATE[$i]} $sp ${ARR_ATTACH[$i]} $sp ${ARR_IID[$i]} $sp \
                      ${ARR_VTYPE[$i]} $sp ${ARR_TAG[$i]} $sp" >> .body.tmp
                # incr ct
                i=$(( $i+1 ))
            done
            # print header
            print_header "$sp Volume-Id $sp Size $sp CreateTime* $sp State $sp Attached $sp InstanceId $sp VolType $sp" $total_width .ec2-qv-volumes.tmp
            # sort body text
            cat .body.tmp | sort -k5 -r >> .ec2-qv-volumes.tmp
            awk  '{ printf "%-2s %-23s %-2s %-6s %-2s %-12s %-2s %-10s %-2s %-20s %-2s %-23s %-2s %-10s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17}' .ec2-qv-volumes.tmp | indent02
        fi
        # size, unit calcs of raw volumes
        RETURN=$(adjust_units $SUM)
        ASUM=$(echo $RETURN | awk '{print $1}')
        UNIT=$(echo $RETURN | awk '{print $2}')
        # print footer
        print_footer "${title}$MAXCT${body} volumes in region [$REGION], total "${title}$ASUM${body}" $UNIT" $total_width

        # clean up
        rm .ec2-qv-volumes.tmp .body.tmp .jsonoutput.tmp
    fi
    #
    # <-- end function ec2cli_list_volumes -->
    #
}

function ec2cli_list_vpcs(){
    # vars
    local region="$1"
    local total_width="118"
    local sp="${frame}|${body}"       # separator
    # print region identifier
    printf "\n${white}${BOLD}Virtual Private Clouds (VPC)${UNBOLD}${reset} : $REGION\n\n" | indent18
    # print header
    print_header "VpcId State Tenancy CIDR-Block Default" $total_width .report.tmp
    # output from aws
    aws ec2 --profile $PROFILE describe-vpcs --output json --region $REGION > .jsonoutput.json
    aws ec2 --profile $PROFILE describe-vpcs \
        --output text \
        --region $REGION \
        --query "Vpcs[*]. \
            [VpcId, \
            State, \
            InstanceTenancy, \
            CidrBlock, \
            IsDefault]" | sort -k +4n \
    >> .ec2-qv-vpc.tmp

    # parse json
    ARR_ID=( $(jq -r '.Vpcs[].VpcId' .jsonoutput.json) )
    ARR_DEFAULT=( $(jq -r '.Vpcs[].IsDefault' .jsonoutput.json) )
    ARR_STATE=( $(jq -r '.Vpcs[].State' .jsonoutput.json) )
    ARR_TENANCY=( $(jq -r '.Vpcs[].InstanceTenancy' .jsonoutput.json) )
    ARR_CIDR=( $(jq -r '.Vpcs[].CidrBlock' .jsonoutput.json) )
    ARR_DHCP=( $(jq -r '.Vpcs[].DhcpOptionsId' .jsonoutput.json) )
    ARR_TAG=( $(jq -r '.Vpcs[].Tags[0].Value' .jsonoutput.json | cut -c 1-20) )

    MAXCT=${#ARR_ID[*]}    # count snapshots found
    # output table of json array
    i=0
    while (( i < $MAXCT )); do
        echo "$sp ${ARR_ID[$i]} $sp $(if [ "${ARR_DEFAULT[$i]}" = "true" ]; then echo "yes"; else echo "-"; fi) $sp ${ARR_STATE[$i]} $sp \
              ${ARR_TENANCY[$i]} $sp ${ARR_CIDR[$i]} $sp ${ARR_DHCP[$i]} $sp \
              ${ARR_TAG[$i]} $sp" >> .body.tmp
        # incr ct
        i=$(( $i+1 ))
    done
    # print header
    print_header "$sp VpcId $sp Default? $sp State $sp Tenancy $sp CIDR $sp DHCP-Options $sp Tag $sp" $total_width .report.tmp
    # sort body text
    cat .body.tmp | sort -k +10n  >> .report.tmp
    # print and format output
    awk  '{ printf "%-2s %-14s %-2s %-10s %-2s %-12s %-2s %-10s %-2s %-15s %-2s %-15s %-2s %-20s %-2s\n", \
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15}' .report.tmp | indent02
    # print footer
    print_footer "Total VPCs, $REGION: ${white}${BOLD}$MAXCT${UNBOLD}${reset}" $total_width
    # clean up
    rm .jsonoutput.json .body.tmp .report.tmp
    #
    # <-- end function ec2cli_list_vpcs -->
    #
}

function setup_regioncodes(){
    ## writeout region codes to config file, every REFRESH_REGIONCODES freq ##
    local age
    local mtime
    local allowable_age_secs
    local recreate_flag=""
    local now=$(date -u +%s)
    local regioncodes="$CONFIG_PATH/$REGION_CONFIGFILE"
    #
    if [ -f "$CONFIG_PATH/$REGION_CONFIGFILE" ]; then
        # check file age
        mtime=$(stat -c %Y $CONFIG_PATH/$REGION_CONFIGFILE)
        age=$(( $now - $mtime ))
        allowable_age_secs=$(( $REFRESH_REGIONCODES * 24 * 60 * 60 ))
        if [ $age -gt $allowable_age_secs ]; then
            # refresh region codes
            std_logger "[INFO]: Regioncode file age: $(( $age / 24 / 60 / 60 )) days"
            std_logger "[INFO]: Allowable file age: $REFRESH_REGIONCODES days"
            std_logger "[INFO]: Refresh region codes set to True"
            recreate_flag="True"
        fi
        std_logger "[INFO]: Region code config file ($regioncodes) found, age $(($age/24/60/60)) days"
        std_logger "[INFO]: $(cat $regioncodes | wc -l) Regions identified"
    fi
    if [ ! -f "$CONFIG_PATH/$REGION_CONFIGFILE" ] || [ $recreate_flag ]; then
        std_logger "[INFO]: (re)creating REGION_CONFIGFILE ($CONFIG_PATH/$REGION_CONFIGFILE)"
        JSON_REGIONS=$(aws ec2 describe-regions --output json)
        echo $JSON_REGIONS | jq -r .Regions[].RegionName > "$CONFIG_PATH/$REGION_CONFIGFILE"
    fi
    return
}

function parse_regioncode(){
    ## retrieve codes for all valid AWS Regions globally ##
    user_provided="$1"
    #
    case $user_provided in
        -p | --profile | -d | --debug | -h | --help)
            return 1
            ;;
    esac

    # parameter is a region, validate it
    if [ "$(grep $user_provided "$CONFIG_PATH/$REGION_CONFIGFILE")" == "$user_provided" ]; then
        # aws region given
        REGION=$user_provided
    else
        # bad regioncode
        std_error_exit "Invalid AWS region code [ $1 ]. See ec2cli --help. Exiting (code $E_BADARG)" $E_BADARG
    fi
    #
    # <-- end function parse_regioncode -->
}


function parse_command(){
    COMMAND="$1"
    #
    std_logger "[INFO]: parse_command: COMMAND parameter received is ($COMMAND)"
    # check if command is a region code
    if [[ $COMMAND = ??-*-[1-9] ]]; then
        # region code given instead
        # user requests default (list)
        parse_regioncode $COMMAND
        COMMAND="list"    # set to default, no command given
        return
    elif [[ $COMMAND = i-* ]] || [[ $COMMAND = subnet-* ]] || [[ $COMMAND = vpc-* ]] \
        || [[ $COMMAND = ami-* ]] || [[ $COMMAND = sg-* ]] || [[ $COMMAND = snap-* ]]  \
        || [[ $COMMAND = vol-* ]]; then
        # resource id given instead of a command
        RESOURCEID=$COMMAND
        COMMAND="list"    # set to default, resource-id given instead of command
        return
    elif [ ! $COMMAND ]; then
        # command blank
        std_warn "You must provide a command"
        exit $E_DEPENDENCY
    else
        case $COMMAND in
            attach | Attach | ATTACH)
                COMMAND="attach"
                ;;
            list | List | LIST)
                COMMAND="list"
                ;;
            create | Create | CREATE)
                COMMAND="create"
                ;;
            run | Run | RUN | ru | r | start | Start)
                COMMAND="run"
                ;;
            *)
                std_logger "[WARN]: Not a recognized COMMAND ($COMMAND), assume default COMMAND"
                COMMAND="list"
                return 1
                ;;
        esac
    fi
    #
    # <-- end function parse_command -->
}


function set_default_region(){
    ## finds out default region ##
    profile_name="$1"
    #
    awscli=$(which aws)
    DEFAULT_REGION=$($awscli configure get $profile_name.region)
    if [ ! $DEFAULT_REGION ]; then
        if [ $AWS_DEFAULT_REGION ]; then
            DEFAULT_REGION=$AWS_DEFAULT_REGION
        elif [ ! $AWS_DEFAULT_REGION ]; then
            std_error_exit "You must enter an AWS regioncode -- A default region was not found in your user profile. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    std_logger "[INFO]: DEFAULT_REGION identified as:  $DEFAULT_REGION"
}


function set_profile(){
    local profilename="$1"
    if [ $profilename ]; then
        PROFILE=$profilename
    else
        std_warn "You must provide a profile name when using -p / --profile parameter"
    fi
}


function parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        ec2cli_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --h | -help | --help)
                    # display help
                    ec2cli_help
                    exit 0
                    ;;
                -d | --debug | --dbug)
                    ## enable verbose logging and output ##
                    DBUGMODE="True"
                    std_logger "[INFO]: DBUGMODE enabled, set to True"
                    shift 1
                    ;;
                -p | --profile)
                    if [ $2 ]; then
                        PROFILE="$2"
                    else
                        std_warn "You must provide a profile name when using --profile parameter"
                    fi
                    shift 2
                    ;;
                -a | --images | --ami)
                    #
                    # display details of Amazon Machine Images for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_images"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_images"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -b | -subnets | --subnet | --subnets)
                    #
                    # display details of all regional vpc subnets
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_subnets"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -g | --sgroups | --securitygroups)
                    #
                    # display details of EC2 security groups for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_securitygroups"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -i | --instances)
                    #
                    # display instances details for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_instances"
                                ;;
                            run)
                                FUNCTION_CALL="ec2cli_run_instances"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -n | --vpcs)
                    #
                    # display details of vpcs for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_vpcs"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                -N | --network | --networks | --Network | --Networks)
        			#
        			# display all network details for region
        			#
                    OPTION="$1"
                    if [ $2 ]; then
                        if ! parse_regioncode $2; then
                            shift 1
                        else shift 2; fi
                    else
                        shift 1
                    fi
        			;;
                -t | --tags)
                    #
                    # Display details of all EC2 tags for region
                    # No region parameter, tags are global
                    OPTION="$1"
                    std_logger "[INFO]: OPTION global set to: ($OPTION)"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_tags"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_tag"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -s | -snapshots | -snapshot | --snapshot | --snapshots)
                    #
                    # display details of EC2 snapshots for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="ec2cli_help_command_list_snapshots"
                        shift 1
                    else
                        case $COMMAND in
                            list)
                                FUNCTION_CALL="ec2cli_list_snapshots"
                                ;;
                            create)
                                FUNCTION_CALL="ec2cli_create_snapshot"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                    ;;
                -v | --volumes)
                    #
                    # display details of EBS Volume Snapshots for region
                    #
                    OPTION="$1"
                    if [ ! $2 ]; then
                        COMMAND="list"
                        shift 1
                    else
                        if ! parse_command $2; then
                            shift 1
                        else shift 2; fi
                    fi
                    # provision for help submenu
                    if [ "$1" = "help" ]; then
                        FUNCTION_CALL="HELP"
                    else
                        case $COMMAND in
                            attach)
                                FUNCTION_CALL="ec2cli_attach_volume"
                                ;;
                            list)
                                FUNCTION_CALL="ec2cli_list_volumes"
                                ;;
                            *)
                                std_message "Command ($2) not valid with option ${BOLD}$1${UNBOLD}" INFO
                                ;;
                        esac
                    fi
                	;;
                ??-*-[1-9])
                    #
                    # regioncode found, validate it
                    #
                    parse_regioncode $1
                    shift 1
                    ;;
                i-* | subnet-* | vpc-* | ami-* | sg-* | snap-* | vol-*)
                    RESOURCEID="$1"
                    shift 1
                    ;;
                -P | --spot)
                    std_logger "[INFO]: entering Spot Market Pricing Menu"
                    FUNCTION_CALL="SPOT_MARKET"
                    shift 1
                    ;;
                -S | --sort)
                    # sort column
                    if [ $2 ]; then
                        SORT_COL="$2"
                        shift 2
                    fi
                    ;;
                help)    # invoke detailed help menu
                    source $pkg_path/lib/help_menus.lib
                    case $COMMAND in
                        attach)
                            ec2cli_help_command_attach
                            exit 0
                            ;;
                        create)
                            ec2cli_help_command_create
                            exit 0
                            ;;
                        list)
                            ec2cli_help_command_list
                            exit 0
                            ;;
                        run)
                            ec2cli_help_command_run
                            exit 0
                            ;;
                    esac
                    ;;
                -V | --version)
                    echo -e "\n${body}Package Info${body}:" | indent04
                    std_message "${orange}ec2cli${body}, version ${title}$VERSION${body}" INFO | indent04
                    echo -e "\n${body}Amazon command line interface (awscli)${body}:\n" | indent04
                    environment_info "INFO" "awscli"
                    echo -e "\n${body}Installed Json Parser:${body}" | indent04
                    environment_info "INFO" "jq"
                    echo -e "\n${body}Operating System:${body}" | indent04
                    environment_info "INFO" "os"
                    exit 0
                    ;;
                *)
                    std_error "Option [ $1 ] unknown. Invalid option specified. (code $E_BADARG)" $E_BADARG
                    exit $E_BADARG
                	;;
            esac
        done
        if [ ! $PROFILE ]; then
            PROFILE="default"
            std_logger "[INFO]: PROFILE default to: default"
        fi

        if [ ! $REGION ]; then
            # determine default region
            set_default_region $PROFILE
            REGION=$DEFAULT_REGION
        fi

        if [ $DBUGMODE ]; then
            std_logger "[INFO]: Debug Mode Enabled, debug set to $DBUGMODE"
        fi
    fi
    #
    # <-- end function ec2cli_parse_parameters -->
}

function xterm_reset(){
    ## resets default xterm colors (temporary) ##
    local set_colors="$1"
    #
    if [ $set_colors ]; then
        PS1_ORIGINAL="$PS1"
        export PS1="$PS1_ORIGINAL \$\[\${orange}\]"
    else
        # reset to orginal
        export PS1=$PS1_ORIGINAL
    fi
}

#
# START (MAIN) ----------------------------------------------------------------
#

# validate pre-run conditions
ec2cli_precheck

# reset default colors
#xterm_reset true

# parse all cli parameters
parse_parameters $@

# execute
if [ $DBUGMODE ]; then
    echo -e "PROFILE: $PROFILE"
    echo -e "COMMAND: $COMMAND"
    echo -e "REGION: $REGION"
    echo -e "FUNCTION_CALL: $FUNCTION_CALL"
    if [ $RESOURCEID ]; then
        echo -e "RESOURCEID: $RESOURCEID"
    fi
fi


if [ "$FUNCTION_CALL" = "HELP" ]; then
    source $pkg_path/lib/help_menus.lib
    help_submenu $COMMAND
elif [ "$FUNCTION_CALL" = "ec2cli_help_command_list_snapshots" ]; then
    source $pkg_path/lib/help_menus.lib
    ec2cli_help_command_list_snapshots
else
    # execute operations which require authentication to AWS
    if authenticated $PROFILE; then
        # authenicated to aws successful
        if { [ "$OPTION" = "--tags" ] || [ "$OPTION" = "-t" ]; } && [ "$COMMAND" = "list" ]; then
            $FUNCTION_CALL $REGION $RESOURCEID

        elif { [ "$OPTION" = "--tags" ] || [ "$OPTION" = "-t" ]; } && [ "$COMMAND" = "create" ]; then
            $FUNCTION_CALL $REGION $RESOURCEID

        elif [ "$OPTION" = '-N' ] || [ "$OPTION" = '--network' ]; then
            ec2cli_list_vpcs $REGION
            ec2cli_list_subnets $REGION
            ec2cli_list_securitygroups $REGION

        elif [ "$FUNCTION_CALL" = "SPOT_MARKET" ]; then
            sh $pkg_path/lib/spot-prices.sh

        else
            $FUNCTION_CALL $REGION $SORT_COL
        fi
    fi
fi

# reset terminal colors to original
#xterm_reset

#
# END (MAIN) ------------------------------------------------------------------
#

exit 0
